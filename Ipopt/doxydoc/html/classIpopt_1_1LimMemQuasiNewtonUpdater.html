<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>Ipopt: Ipopt::LimMemQuasiNewtonUpdater Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Ipopt
   &#160;<span id="projectnumber">3.12.8</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceIpopt.html">Ipopt</a></li><li class="navelem"><a class="el" href="classIpopt_1_1LimMemQuasiNewtonUpdater.html">LimMemQuasiNewtonUpdater</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classIpopt_1_1LimMemQuasiNewtonUpdater-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Ipopt::LimMemQuasiNewtonUpdater Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Implementation of the <a class="el" href="classIpopt_1_1HessianUpdater.html" title="Abstract base class for objects responsible for updating the Hessian information. ...">HessianUpdater</a> for limit-memory quasi-Newton approximation of the Lagrangian Hessian.  
 <a href="classIpopt_1_1LimMemQuasiNewtonUpdater.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="IpLimMemQuasiNewtonUpdater_8hpp_source.html">IpLimMemQuasiNewtonUpdater.hpp</a>&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for Ipopt::LimMemQuasiNewtonUpdater:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><img src="classIpopt_1_1LimMemQuasiNewtonUpdater__inherit__graph.png" border="0" usemap="#Ipopt_1_1LimMemQuasiNewtonUpdater_inherit__map" alt="Inheritance graph"/></div>
<map name="Ipopt_1_1LimMemQuasiNewtonUpdater_inherit__map" id="Ipopt_1_1LimMemQuasiNewtonUpdater_inherit__map">
<area shape="rect" id="node2" href="classIpopt_1_1HessianUpdater.html" title="Abstract base class for objects responsible for updating the Hessian information. ..." alt="" coords="23,171,188,197"/><area shape="rect" id="node3" href="classIpopt_1_1AlgorithmStrategyObject.html" title="This is the base class for all algorithm strategy objects. " alt="" coords="16,81,195,122"/><area shape="rect" id="node4" href="classIpopt_1_1ReferencedObject.html" title="ReferencedObject class. " alt="" coords="18,5,192,32"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab6b064e5eff0e16c4aa83983070f20a6"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIpopt_1_1LimMemQuasiNewtonUpdater.html#ab6b064e5eff0e16c4aa83983070f20a6">InitializeImpl</a> (const <a class="el" href="classIpopt_1_1OptionsList.html">OptionsList</a> &amp;options, const std::string &amp;prefix)</td></tr>
<tr class="memdesc:ab6b064e5eff0e16c4aa83983070f20a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">overloaded from <a class="el" href="classIpopt_1_1AlgorithmStrategyObject.html" title="This is the base class for all algorithm strategy objects. ">AlgorithmStrategyObject</a>  <a href="#ab6b064e5eff0e16c4aa83983070f20a6">More...</a><br/></td></tr>
<tr class="separator:ab6b064e5eff0e16c4aa83983070f20a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a195f4bcb6d1c184068e69c97e4b206"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIpopt_1_1LimMemQuasiNewtonUpdater.html#a7a195f4bcb6d1c184068e69c97e4b206">UpdateHessian</a> ()</td></tr>
<tr class="memdesc:a7a195f4bcb6d1c184068e69c97e4b206"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the Hessian based on the current information in IpData.  <a href="#a7a195f4bcb6d1c184068e69c97e4b206">More...</a><br/></td></tr>
<tr class="separator:a7a195f4bcb6d1c184068e69c97e4b206"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructors/Destructors</div></td></tr>
<tr class="memitem:a8ea42c302bc7a9cd98835e06d1395449"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIpopt_1_1LimMemQuasiNewtonUpdater.html#a8ea42c302bc7a9cd98835e06d1395449">LimMemQuasiNewtonUpdater</a> (bool update_for_resto)</td></tr>
<tr class="memdesc:a8ea42c302bc7a9cd98835e06d1395449"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default Constructor.  <a href="#a8ea42c302bc7a9cd98835e06d1395449">More...</a><br/></td></tr>
<tr class="separator:a8ea42c302bc7a9cd98835e06d1395449"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a965ff2daa98ef1e330111e5feef2f113"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIpopt_1_1LimMemQuasiNewtonUpdater.html#a965ff2daa98ef1e330111e5feef2f113">~LimMemQuasiNewtonUpdater</a> ()</td></tr>
<tr class="memdesc:a965ff2daa98ef1e330111e5feef2f113"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default destructor.  <a href="#a965ff2daa98ef1e330111e5feef2f113">More...</a><br/></td></tr>
<tr class="separator:a965ff2daa98ef1e330111e5feef2f113"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classIpopt_1_1HessianUpdater"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classIpopt_1_1HessianUpdater')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classIpopt_1_1HessianUpdater.html">Ipopt::HessianUpdater</a></td></tr>
<tr class="memitem:a07851fff009f6ffa3e82cf5925207550 inherit pub_methods_classIpopt_1_1HessianUpdater"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIpopt_1_1HessianUpdater.html#a07851fff009f6ffa3e82cf5925207550">HessianUpdater</a> ()</td></tr>
<tr class="memdesc:a07851fff009f6ffa3e82cf5925207550 inherit pub_methods_classIpopt_1_1HessianUpdater"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default Constructor.  <a href="#a07851fff009f6ffa3e82cf5925207550">More...</a><br/></td></tr>
<tr class="separator:a07851fff009f6ffa3e82cf5925207550 inherit pub_methods_classIpopt_1_1HessianUpdater"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af260f8323f2579c3d71dfeb16fb8f201 inherit pub_methods_classIpopt_1_1HessianUpdater"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIpopt_1_1HessianUpdater.html#af260f8323f2579c3d71dfeb16fb8f201">~HessianUpdater</a> ()</td></tr>
<tr class="memdesc:af260f8323f2579c3d71dfeb16fb8f201 inherit pub_methods_classIpopt_1_1HessianUpdater"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default destructor.  <a href="#af260f8323f2579c3d71dfeb16fb8f201">More...</a><br/></td></tr>
<tr class="separator:af260f8323f2579c3d71dfeb16fb8f201 inherit pub_methods_classIpopt_1_1HessianUpdater"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classIpopt_1_1AlgorithmStrategyObject"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classIpopt_1_1AlgorithmStrategyObject')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classIpopt_1_1AlgorithmStrategyObject.html">Ipopt::AlgorithmStrategyObject</a></td></tr>
<tr class="memitem:aa2cb1ac4ea5b97c9283bc0fdb71da1d1 inherit pub_methods_classIpopt_1_1AlgorithmStrategyObject"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIpopt_1_1AlgorithmStrategyObject.html#aa2cb1ac4ea5b97c9283bc0fdb71da1d1">Initialize</a> (const <a class="el" href="classIpopt_1_1Journalist.html">Journalist</a> &amp;jnlst, <a class="el" href="classIpopt_1_1IpoptNLP.html">IpoptNLP</a> &amp;ip_nlp, <a class="el" href="classIpopt_1_1IpoptData.html">IpoptData</a> &amp;ip_data, <a class="el" href="classIpopt_1_1IpoptCalculatedQuantities.html">IpoptCalculatedQuantities</a> &amp;ip_cq, const <a class="el" href="classIpopt_1_1OptionsList.html">OptionsList</a> &amp;options, const std::string &amp;prefix)</td></tr>
<tr class="memdesc:aa2cb1ac4ea5b97c9283bc0fdb71da1d1 inherit pub_methods_classIpopt_1_1AlgorithmStrategyObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method is called every time the algorithm starts again - it is used to reset any internal state.  <a href="#aa2cb1ac4ea5b97c9283bc0fdb71da1d1">More...</a><br/></td></tr>
<tr class="separator:aa2cb1ac4ea5b97c9283bc0fdb71da1d1 inherit pub_methods_classIpopt_1_1AlgorithmStrategyObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac624e5a883f5c655cb0abbaa24eafcf9 inherit pub_methods_classIpopt_1_1AlgorithmStrategyObject"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIpopt_1_1AlgorithmStrategyObject.html#ac624e5a883f5c655cb0abbaa24eafcf9">ReducedInitialize</a> (const <a class="el" href="classIpopt_1_1Journalist.html">Journalist</a> &amp;jnlst, const <a class="el" href="classIpopt_1_1OptionsList.html">OptionsList</a> &amp;options, const std::string &amp;prefix)</td></tr>
<tr class="memdesc:ac624e5a883f5c655cb0abbaa24eafcf9 inherit pub_methods_classIpopt_1_1AlgorithmStrategyObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduced version of the Initialize method, which does not require special <a class="el" href="namespaceIpopt.html">Ipopt</a> information.  <a href="#ac624e5a883f5c655cb0abbaa24eafcf9">More...</a><br/></td></tr>
<tr class="separator:ac624e5a883f5c655cb0abbaa24eafcf9 inherit pub_methods_classIpopt_1_1AlgorithmStrategyObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2d972f86eec83a96682bd6741a1d265 inherit pub_methods_classIpopt_1_1AlgorithmStrategyObject"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIpopt_1_1AlgorithmStrategyObject.html#af2d972f86eec83a96682bd6741a1d265">AlgorithmStrategyObject</a> ()</td></tr>
<tr class="memdesc:af2d972f86eec83a96682bd6741a1d265 inherit pub_methods_classIpopt_1_1AlgorithmStrategyObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default Constructor.  <a href="#af2d972f86eec83a96682bd6741a1d265">More...</a><br/></td></tr>
<tr class="separator:af2d972f86eec83a96682bd6741a1d265 inherit pub_methods_classIpopt_1_1AlgorithmStrategyObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea25a150f7488885653c082eca5dab45 inherit pub_methods_classIpopt_1_1AlgorithmStrategyObject"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIpopt_1_1AlgorithmStrategyObject.html#aea25a150f7488885653c082eca5dab45">~AlgorithmStrategyObject</a> ()</td></tr>
<tr class="memdesc:aea25a150f7488885653c082eca5dab45 inherit pub_methods_classIpopt_1_1AlgorithmStrategyObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default Destructor.  <a href="#aea25a150f7488885653c082eca5dab45">More...</a><br/></td></tr>
<tr class="separator:aea25a150f7488885653c082eca5dab45 inherit pub_methods_classIpopt_1_1AlgorithmStrategyObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classIpopt_1_1ReferencedObject"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classIpopt_1_1ReferencedObject')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classIpopt_1_1ReferencedObject.html">Ipopt::ReferencedObject</a></td></tr>
<tr class="memitem:a5c0f2208e3ead22bf7c5179381ed8203 inherit pub_methods_classIpopt_1_1ReferencedObject"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIpopt_1_1ReferencedObject.html#a5c0f2208e3ead22bf7c5179381ed8203">ReferencedObject</a> ()</td></tr>
<tr class="separator:a5c0f2208e3ead22bf7c5179381ed8203 inherit pub_methods_classIpopt_1_1ReferencedObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbbf3aa5307da62ab8224ba599d4bd7a inherit pub_methods_classIpopt_1_1ReferencedObject"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIpopt_1_1ReferencedObject.html#adbbf3aa5307da62ab8224ba599d4bd7a">~ReferencedObject</a> ()</td></tr>
<tr class="separator:adbbf3aa5307da62ab8224ba599d4bd7a inherit pub_methods_classIpopt_1_1ReferencedObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15da3ef3495ac43bcc6a7104c94f1d96 inherit pub_methods_classIpopt_1_1ReferencedObject"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceIpopt.html#a8728e67558138991e8ee3fea451dca94">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIpopt_1_1ReferencedObject.html#a15da3ef3495ac43bcc6a7104c94f1d96">ReferenceCount</a> () const </td></tr>
<tr class="separator:a15da3ef3495ac43bcc6a7104c94f1d96 inherit pub_methods_classIpopt_1_1ReferencedObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5595bbcfa0db055b5e61a0c343fcd866 inherit pub_methods_classIpopt_1_1ReferencedObject"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIpopt_1_1ReferencedObject.html#a5595bbcfa0db055b5e61a0c343fcd866">AddRef</a> (const <a class="el" href="classIpopt_1_1Referencer.html">Referencer</a> *referencer) const </td></tr>
<tr class="separator:a5595bbcfa0db055b5e61a0c343fcd866 inherit pub_methods_classIpopt_1_1ReferencedObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af62883682d455f1afeeac7978c4b50c1 inherit pub_methods_classIpopt_1_1ReferencedObject"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIpopt_1_1ReferencedObject.html#af62883682d455f1afeeac7978c4b50c1">ReleaseRef</a> (const <a class="el" href="classIpopt_1_1Referencer.html">Referencer</a> *referencer) const </td></tr>
<tr class="separator:af62883682d455f1afeeac7978c4b50c1 inherit pub_methods_classIpopt_1_1ReferencedObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a3188133b8913b894c778ddc89d6c3dd2"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIpopt_1_1LimMemQuasiNewtonUpdater.html#a3188133b8913b894c778ddc89d6c3dd2">RegisterOptions</a> (<a class="el" href="classIpopt_1_1SmartPtr.html">SmartPtr</a>&lt; <a class="el" href="classIpopt_1_1RegisteredOptions.html">RegisteredOptions</a> &gt; roptions)</td></tr>
<tr class="memdesc:a3188133b8913b894c778ddc89d6c3dd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Methods for <a class="el" href="classIpopt_1_1OptionsList.html" title="This class stores a list of user set options. ">OptionsList</a>.  <a href="#a3188133b8913b894c778ddc89d6c3dd2">More...</a><br/></td></tr>
<tr class="separator:a3188133b8913b894c778ddc89d6c3dd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Default Compiler Generated Methods</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>(Hidden to avoid implicit creation/calling).</p>
<p>These methods are not implemented and we do not want the compiler to implement them for us, so we declare them private and do not define them. This ensures that they will not be implicitly created/called. </p>
</div></td></tr>
<tr class="memitem:a8529529ce958964fa629b4bb28ce5c76"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIpopt_1_1LimMemQuasiNewtonUpdater.html#a8529529ce958964fa629b4bb28ce5c76">LimMemQuasiNewtonUpdater</a> (const <a class="el" href="classIpopt_1_1LimMemQuasiNewtonUpdater.html">LimMemQuasiNewtonUpdater</a> &amp;)</td></tr>
<tr class="memdesc:a8529529ce958964fa629b4bb28ce5c76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy Constructor.  <a href="#a8529529ce958964fa629b4bb28ce5c76">More...</a><br/></td></tr>
<tr class="separator:a8529529ce958964fa629b4bb28ce5c76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4709f2080300a8151c009a5bf79f0873"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIpopt_1_1LimMemQuasiNewtonUpdater.html#a4709f2080300a8151c009a5bf79f0873">operator=</a> (const <a class="el" href="classIpopt_1_1LimMemQuasiNewtonUpdater.html">LimMemQuasiNewtonUpdater</a> &amp;)</td></tr>
<tr class="memdesc:a4709f2080300a8151c009a5bf79f0873"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloaded Equals Operator.  <a href="#a4709f2080300a8151c009a5bf79f0873">More...</a><br/></td></tr>
<tr class="separator:a4709f2080300a8151c009a5bf79f0873"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Auxilliary function</div></td></tr>
<tr class="memitem:a69c33a153dd61a75ba5e4748f3cd5fa6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIpopt_1_1LimMemQuasiNewtonUpdater.html#a69c33a153dd61a75ba5e4748f3cd5fa6">CheckSkippingBFGS</a> (<a class="el" href="classIpopt_1_1Vector.html">Vector</a> &amp;s_new, <a class="el" href="classIpopt_1_1Vector.html">Vector</a> &amp;y_new)</td></tr>
<tr class="memdesc:a69c33a153dd61a75ba5e4748f3cd5fa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method deciding whether the BFGS update should be skipped.  <a href="#a69c33a153dd61a75ba5e4748f3cd5fa6">More...</a><br/></td></tr>
<tr class="separator:a69c33a153dd61a75ba5e4748f3cd5fa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ea94f5ef65c96962c804c289085af51"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIpopt_1_1LimMemQuasiNewtonUpdater.html#a4ea94f5ef65c96962c804c289085af51">UpdateInternalData</a> (const <a class="el" href="classIpopt_1_1Vector.html">Vector</a> &amp;s_new, const <a class="el" href="classIpopt_1_1Vector.html">Vector</a> &amp;y_new, <a class="el" href="classIpopt_1_1SmartPtr.html">SmartPtr</a>&lt; <a class="el" href="classIpopt_1_1Vector.html">Vector</a> &gt; ypart_new)</td></tr>
<tr class="memdesc:a4ea94f5ef65c96962c804c289085af51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the internal data, such as the S, Y, L, D etc matrices and vectors that are required for computing the compact representation.  <a href="#a4ea94f5ef65c96962c804c289085af51">More...</a><br/></td></tr>
<tr class="separator:a4ea94f5ef65c96962c804c289085af51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a281068ccae8573fa1579f72a1130d8a7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIpopt_1_1LimMemQuasiNewtonUpdater.html#a281068ccae8573fa1579f72a1130d8a7">AugmentMultiVector</a> (<a class="el" href="classIpopt_1_1SmartPtr.html">SmartPtr</a>&lt; <a class="el" href="classIpopt_1_1MultiVectorMatrix.html">MultiVectorMatrix</a> &gt; &amp;V, const <a class="el" href="classIpopt_1_1Vector.html">Vector</a> &amp;v_new)</td></tr>
<tr class="memdesc:a281068ccae8573fa1579f72a1130d8a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a MutliVector V, create a new MultiVectorSpace with one more column, and return V as a member of that space, consisting of all previous vectors, and in addition v_new in the last column.  <a href="#a281068ccae8573fa1579f72a1130d8a7">More...</a><br/></td></tr>
<tr class="separator:a281068ccae8573fa1579f72a1130d8a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3347d0c1aaf05f4cb0b0a1f1befeea36"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIpopt_1_1LimMemQuasiNewtonUpdater.html#a3347d0c1aaf05f4cb0b0a1f1befeea36">AugmentDenseVector</a> (<a class="el" href="classIpopt_1_1SmartPtr.html">SmartPtr</a>&lt; <a class="el" href="classIpopt_1_1DenseVector.html">DenseVector</a> &gt; &amp;V, <a class="el" href="namespaceIpopt.html#ad77ec4132352c5093febf9c488a72a4c">Number</a> v_new)</td></tr>
<tr class="memdesc:a3347d0c1aaf05f4cb0b0a1f1befeea36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a <a class="el" href="classIpopt_1_1DenseVector.html" title="Dense Vector Implementation. ">DenseVector</a> V, create a new <a class="el" href="classIpopt_1_1DenseVectorSpace.html" title="This vectors space is the vector space for DenseVector. ">DenseVectorSpace</a> with one more row, and return V as a member of that space, consisting of all previous elements, and in addition v_new in the last row.  <a href="#a3347d0c1aaf05f4cb0b0a1f1befeea36">More...</a><br/></td></tr>
<tr class="separator:a3347d0c1aaf05f4cb0b0a1f1befeea36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa89449bb9bffcc06bd6f723f97abc08c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIpopt_1_1LimMemQuasiNewtonUpdater.html#aa89449bb9bffcc06bd6f723f97abc08c">AugmentLMatrix</a> (<a class="el" href="classIpopt_1_1SmartPtr.html">SmartPtr</a>&lt; <a class="el" href="classIpopt_1_1DenseGenMatrix.html">DenseGenMatrix</a> &gt; &amp;V, const <a class="el" href="classIpopt_1_1MultiVectorMatrix.html">MultiVectorMatrix</a> &amp;S, const <a class="el" href="classIpopt_1_1MultiVectorMatrix.html">MultiVectorMatrix</a> &amp;Y)</td></tr>
<tr class="memdesc:aa89449bb9bffcc06bd6f723f97abc08c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a strictly-lower triangular square <a class="el" href="classIpopt_1_1DenseGenMatrix.html" title="Class for dense general matrices. ">DenseGenMatrix</a> V, create a new <a class="el" href="classIpopt_1_1DenseGenMatrixSpace.html" title="This is the matrix space for DenseGenMatrix. ">DenseGenMatrixSpace</a> with one more dimension, and return V as a member of that space, consisting of all previous elements, and in addition elements s_i^Ty_j for (i&lt;j), where s and y are the vectors in the MultiVectors S and Y.  <a href="#aa89449bb9bffcc06bd6f723f97abc08c">More...</a><br/></td></tr>
<tr class="separator:aa89449bb9bffcc06bd6f723f97abc08c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab25f342f56b53a2dc86368f20140bd36"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIpopt_1_1LimMemQuasiNewtonUpdater.html#ab25f342f56b53a2dc86368f20140bd36">AugmentSdotSMatrix</a> (<a class="el" href="classIpopt_1_1SmartPtr.html">SmartPtr</a>&lt; <a class="el" href="classIpopt_1_1DenseSymMatrix.html">DenseSymMatrix</a> &gt; &amp;V, const <a class="el" href="classIpopt_1_1MultiVectorMatrix.html">MultiVectorMatrix</a> &amp;S)</td></tr>
<tr class="memdesc:ab25f342f56b53a2dc86368f20140bd36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a <a class="el" href="classIpopt_1_1DenseSymMatrix.html" title="Class for dense symetrix matrices. ">DenseSymMatrix</a> V, create a new <a class="el" href="classIpopt_1_1DenseGenMatrixSpace.html" title="This is the matrix space for DenseGenMatrix. ">DenseGenMatrixSpace</a> with one more dimension, and return V as a member of that space, consisting of all previous elements, and in addition elements s_i^Ts_j for the new entries, where s are the vectors in the MultiVector S.  <a href="#ab25f342f56b53a2dc86368f20140bd36">More...</a><br/></td></tr>
<tr class="separator:ab25f342f56b53a2dc86368f20140bd36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03996ca8af26c62753acf1802f9df486"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIpopt_1_1LimMemQuasiNewtonUpdater.html#a03996ca8af26c62753acf1802f9df486">AugmentSTDRSMatrix</a> (<a class="el" href="classIpopt_1_1SmartPtr.html">SmartPtr</a>&lt; <a class="el" href="classIpopt_1_1DenseSymMatrix.html">DenseSymMatrix</a> &gt; &amp;V, const <a class="el" href="classIpopt_1_1MultiVectorMatrix.html">MultiVectorMatrix</a> &amp;S, const <a class="el" href="classIpopt_1_1MultiVectorMatrix.html">MultiVectorMatrix</a> &amp;DRS)</td></tr>
<tr class="memdesc:a03996ca8af26c62753acf1802f9df486"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a <a class="el" href="classIpopt_1_1DenseSymMatrix.html" title="Class for dense symetrix matrices. ">DenseSymMatrix</a> V, create a new <a class="el" href="classIpopt_1_1DenseGenMatrixSpace.html" title="This is the matrix space for DenseGenMatrix. ">DenseGenMatrixSpace</a> with one more dimension, and return V as a member of that space, consisting of all previous elements, and in addition elements s_i^TDRs_j for the new entries, where s are the vectors in the MultiVector S, and DRs are the vectors in DRS.  <a href="#a03996ca8af26c62753acf1802f9df486">More...</a><br/></td></tr>
<tr class="separator:a03996ca8af26c62753acf1802f9df486"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac93aefcf009ce32ab2821b8e5b296d88"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIpopt_1_1LimMemQuasiNewtonUpdater.html#ac93aefcf009ce32ab2821b8e5b296d88">ShiftMultiVector</a> (<a class="el" href="classIpopt_1_1SmartPtr.html">SmartPtr</a>&lt; <a class="el" href="classIpopt_1_1MultiVectorMatrix.html">MultiVectorMatrix</a> &gt; &amp;V, const <a class="el" href="classIpopt_1_1Vector.html">Vector</a> &amp;v_new)</td></tr>
<tr class="memdesc:ac93aefcf009ce32ab2821b8e5b296d88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a MutliVector V, get rid of the first column, shift all other columns to the left, and make v_new the last column.  <a href="#ac93aefcf009ce32ab2821b8e5b296d88">More...</a><br/></td></tr>
<tr class="separator:ac93aefcf009ce32ab2821b8e5b296d88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01a1da7d35c0fd842db33fad7c931da1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIpopt_1_1LimMemQuasiNewtonUpdater.html#a01a1da7d35c0fd842db33fad7c931da1">ShiftDenseVector</a> (<a class="el" href="classIpopt_1_1SmartPtr.html">SmartPtr</a>&lt; <a class="el" href="classIpopt_1_1DenseVector.html">DenseVector</a> &gt; &amp;V, <a class="el" href="namespaceIpopt.html#ad77ec4132352c5093febf9c488a72a4c">Number</a> v_new)</td></tr>
<tr class="memdesc:a01a1da7d35c0fd842db33fad7c931da1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a <a class="el" href="classIpopt_1_1DenseVector.html" title="Dense Vector Implementation. ">DenseVector</a> V, get rid of the first element, shift all other elements one position to the top, and make v_new the last entry.  <a href="#a01a1da7d35c0fd842db33fad7c931da1">More...</a><br/></td></tr>
<tr class="separator:a01a1da7d35c0fd842db33fad7c931da1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d80493f4d0f2ce08ac61bd0c6d97821"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIpopt_1_1LimMemQuasiNewtonUpdater.html#a4d80493f4d0f2ce08ac61bd0c6d97821">ShiftLMatrix</a> (<a class="el" href="classIpopt_1_1SmartPtr.html">SmartPtr</a>&lt; <a class="el" href="classIpopt_1_1DenseGenMatrix.html">DenseGenMatrix</a> &gt; &amp;V, const <a class="el" href="classIpopt_1_1MultiVectorMatrix.html">MultiVectorMatrix</a> &amp;S, const <a class="el" href="classIpopt_1_1MultiVectorMatrix.html">MultiVectorMatrix</a> &amp;Y)</td></tr>
<tr class="memdesc:a4d80493f4d0f2ce08ac61bd0c6d97821"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a strictly-lower triangular square <a class="el" href="classIpopt_1_1DenseGenMatrix.html" title="Class for dense general matrices. ">DenseGenMatrix</a> V, shift everything one row and column up, and fill the new strictly lower triangular entries as s_i^Ty_j for (i&lt;j), where s and y are the vectors in the MultiVectors S and Y.  <a href="#a4d80493f4d0f2ce08ac61bd0c6d97821">More...</a><br/></td></tr>
<tr class="separator:a4d80493f4d0f2ce08ac61bd0c6d97821"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30e0b5e73c9c3a90db01980aac74a8e6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIpopt_1_1LimMemQuasiNewtonUpdater.html#a30e0b5e73c9c3a90db01980aac74a8e6">ShiftSdotSMatrix</a> (<a class="el" href="classIpopt_1_1SmartPtr.html">SmartPtr</a>&lt; <a class="el" href="classIpopt_1_1DenseSymMatrix.html">DenseSymMatrix</a> &gt; &amp;V, const <a class="el" href="classIpopt_1_1MultiVectorMatrix.html">MultiVectorMatrix</a> &amp;S)</td></tr>
<tr class="memdesc:a30e0b5e73c9c3a90db01980aac74a8e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a <a class="el" href="classIpopt_1_1DenseSymMatrix.html" title="Class for dense symetrix matrices. ">DenseSymMatrix</a> V, shift everything up one row and column, and fill the new entries as s_i^Ts_j, where s are the vectors in the MultiVector S.  <a href="#a30e0b5e73c9c3a90db01980aac74a8e6">More...</a><br/></td></tr>
<tr class="separator:a30e0b5e73c9c3a90db01980aac74a8e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7aaf1c9d5d6b97fbed3af013aa1d3667"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIpopt_1_1LimMemQuasiNewtonUpdater.html#a7aaf1c9d5d6b97fbed3af013aa1d3667">ShiftSTDRSMatrix</a> (<a class="el" href="classIpopt_1_1SmartPtr.html">SmartPtr</a>&lt; <a class="el" href="classIpopt_1_1DenseSymMatrix.html">DenseSymMatrix</a> &gt; &amp;V, const <a class="el" href="classIpopt_1_1MultiVectorMatrix.html">MultiVectorMatrix</a> &amp;S, const <a class="el" href="classIpopt_1_1MultiVectorMatrix.html">MultiVectorMatrix</a> &amp;DRS)</td></tr>
<tr class="memdesc:a7aaf1c9d5d6b97fbed3af013aa1d3667"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a <a class="el" href="classIpopt_1_1DenseSymMatrix.html" title="Class for dense symetrix matrices. ">DenseSymMatrix</a> V, shift everything up one row and column, and fill the new entries as s_i^TDRs_j, where s are the vectors in the MultiVector S, and DRs are the vectors in DRS.  <a href="#a7aaf1c9d5d6b97fbed3af013aa1d3667">More...</a><br/></td></tr>
<tr class="separator:a7aaf1c9d5d6b97fbed3af013aa1d3667"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ad1d47e72181bb14902c63acc4bc421"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIpopt_1_1LimMemQuasiNewtonUpdater.html#a9ad1d47e72181bb14902c63acc4bc421">RecalcY</a> (<a class="el" href="namespaceIpopt.html#ad77ec4132352c5093febf9c488a72a4c">Number</a> eta, const <a class="el" href="classIpopt_1_1Vector.html">Vector</a> &amp;DR_x, <a class="el" href="classIpopt_1_1MultiVectorMatrix.html">MultiVectorMatrix</a> &amp;S, <a class="el" href="classIpopt_1_1MultiVectorMatrix.html">MultiVectorMatrix</a> &amp;Ypart, <a class="el" href="classIpopt_1_1SmartPtr.html">SmartPtr</a>&lt; <a class="el" href="classIpopt_1_1MultiVectorMatrix.html">MultiVectorMatrix</a> &gt; &amp;Y)</td></tr>
<tr class="memdesc:a9ad1d47e72181bb14902c63acc4bc421"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method for recomputing Y from scratch, using Ypart (only for restoration phase)  <a href="#a9ad1d47e72181bb14902c63acc4bc421">More...</a><br/></td></tr>
<tr class="separator:a9ad1d47e72181bb14902c63acc4bc421"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add79a0ddc6922b9859c2a40e0731d980"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIpopt_1_1LimMemQuasiNewtonUpdater.html#add79a0ddc6922b9859c2a40e0731d980">RecalcD</a> (<a class="el" href="classIpopt_1_1MultiVectorMatrix.html">MultiVectorMatrix</a> &amp;S, <a class="el" href="classIpopt_1_1MultiVectorMatrix.html">MultiVectorMatrix</a> &amp;Y, <a class="el" href="classIpopt_1_1SmartPtr.html">SmartPtr</a>&lt; <a class="el" href="classIpopt_1_1DenseVector.html">DenseVector</a> &gt; &amp;D)</td></tr>
<tr class="memdesc:add79a0ddc6922b9859c2a40e0731d980"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method for recomputing D from S and Y.  <a href="#add79a0ddc6922b9859c2a40e0731d980">More...</a><br/></td></tr>
<tr class="separator:add79a0ddc6922b9859c2a40e0731d980"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af74064858a0134506188b8858d3f697b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIpopt_1_1LimMemQuasiNewtonUpdater.html#af74064858a0134506188b8858d3f697b">RecalcL</a> (<a class="el" href="classIpopt_1_1MultiVectorMatrix.html">MultiVectorMatrix</a> &amp;S, <a class="el" href="classIpopt_1_1MultiVectorMatrix.html">MultiVectorMatrix</a> &amp;Y, <a class="el" href="classIpopt_1_1SmartPtr.html">SmartPtr</a>&lt; <a class="el" href="classIpopt_1_1DenseGenMatrix.html">DenseGenMatrix</a> &gt; &amp;L)</td></tr>
<tr class="memdesc:af74064858a0134506188b8858d3f697b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method for recomputing L from S and Y.  <a href="#af74064858a0134506188b8858d3f697b">More...</a><br/></td></tr>
<tr class="separator:af74064858a0134506188b8858d3f697b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b1dfddf4b1e8a0ea7495e6fc6aaaf97"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIpopt_1_1LimMemQuasiNewtonUpdater.html#a4b1dfddf4b1e8a0ea7495e6fc6aaaf97">SplitEigenvalues</a> (<a class="el" href="classIpopt_1_1DenseGenMatrix.html">DenseGenMatrix</a> &amp;Q, const <a class="el" href="classIpopt_1_1DenseVector.html">DenseVector</a> &amp;E, <a class="el" href="classIpopt_1_1SmartPtr.html">SmartPtr</a>&lt; <a class="el" href="classIpopt_1_1DenseGenMatrix.html">DenseGenMatrix</a> &gt; &amp;Qminus, <a class="el" href="classIpopt_1_1SmartPtr.html">SmartPtr</a>&lt; <a class="el" href="classIpopt_1_1DenseGenMatrix.html">DenseGenMatrix</a> &gt; &amp;Qplus)</td></tr>
<tr class="memdesc:a4b1dfddf4b1e8a0ea7495e6fc6aaaf97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split the eigenvectors into negative and positive ones.  <a href="#a4b1dfddf4b1e8a0ea7495e6fc6aaaf97">More...</a><br/></td></tr>
<tr class="separator:a4b1dfddf4b1e8a0ea7495e6fc6aaaf97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0173e5e0e256e7ad2a8cff90a8fb6c37"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIpopt_1_1LimMemQuasiNewtonUpdater.html#a0173e5e0e256e7ad2a8cff90a8fb6c37">StoreInternalDataBackup</a> ()</td></tr>
<tr class="memdesc:a0173e5e0e256e7ad2a8cff90a8fb6c37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store a copy of the pointers to the internal data (S, Y, D, L, SdotS, curr_lm_memory) This is called in case the update is started but skipped during the process.  <a href="#a0173e5e0e256e7ad2a8cff90a8fb6c37">More...</a><br/></td></tr>
<tr class="separator:a0173e5e0e256e7ad2a8cff90a8fb6c37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e7c02278b58807cd441410d983e3fd0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIpopt_1_1LimMemQuasiNewtonUpdater.html#a8e7c02278b58807cd441410d983e3fd0">RestoreInternalDataBackup</a> ()</td></tr>
<tr class="memdesc:a8e7c02278b58807cd441410d983e3fd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restore the copy of the pointers to the internal data most recently stored with <a class="el" href="classIpopt_1_1LimMemQuasiNewtonUpdater.html#a0173e5e0e256e7ad2a8cff90a8fb6c37" title="Store a copy of the pointers to the internal data (S, Y, D, L, SdotS, curr_lm_memory) This is called ...">StoreInternalDataBackup()</a>.  <a href="#a8e7c02278b58807cd441410d983e3fd0">More...</a><br/></td></tr>
<tr class="separator:a8e7c02278b58807cd441410d983e3fd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a366a223055bf23936869c68d40ae2c4d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIpopt_1_1LimMemQuasiNewtonUpdater.html#a366a223055bf23936869c68d40ae2c4d">ReleaseInternalDataBackup</a> ()</td></tr>
<tr class="memdesc:a366a223055bf23936869c68d40ae2c4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release anything that we allocated for StoreInternalDataBackup and is no longer needed.  <a href="#a366a223055bf23936869c68d40ae2c4d">More...</a><br/></td></tr>
<tr class="separator:a366a223055bf23936869c68d40ae2c4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54a308c4b7b42628732d0fbf4b9081da"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIpopt_1_1LimMemQuasiNewtonUpdater.html#a54a308c4b7b42628732d0fbf4b9081da">SetW</a> ()</td></tr>
<tr class="memdesc:a54a308c4b7b42628732d0fbf4b9081da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the W field in IpData based on the current values of B0_, V_, and U_.  <a href="#a54a308c4b7b42628732d0fbf4b9081da">More...</a><br/></td></tr>
<tr class="separator:a54a308c4b7b42628732d0fbf4b9081da"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:ae651bfdde2b4bb371616d5427f474d92"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIpopt_1_1SmartPtr.html">SmartPtr</a>&lt; const <br class="typebreak"/>
<a class="el" href="classIpopt_1_1LowRankUpdateSymMatrixSpace.html">LowRankUpdateSymMatrixSpace</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIpopt_1_1LimMemQuasiNewtonUpdater.html#ae651bfdde2b4bb371616d5427f474d92">h_space_</a></td></tr>
<tr class="memdesc:ae651bfdde2b4bb371616d5427f474d92"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classIpopt_1_1Matrix.html" title="Matrix Base Class. ">Matrix</a> space for the low-rank Hessian approximation.  <a href="#ae651bfdde2b4bb371616d5427f474d92">More...</a><br/></td></tr>
<tr class="separator:ae651bfdde2b4bb371616d5427f474d92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bf884f069d635a28721132018e82408"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIpopt_1_1LimMemQuasiNewtonUpdater.html#a5bf884f069d635a28721132018e82408">update_for_resto_</a></td></tr>
<tr class="memdesc:a5bf884f069d635a28721132018e82408"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag indicating if the update is to be done for the original <a class="el" href="classIpopt_1_1NLP.html" title="Brief Class Description. ">NLP</a> or for the restoration phase <a class="el" href="classIpopt_1_1NLP.html" title="Brief Class Description. ">NLP</a>.  <a href="#a5bf884f069d635a28721132018e82408">More...</a><br/></td></tr>
<tr class="separator:a5bf884f069d635a28721132018e82408"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef0116647ec48e237647d97ab4652d5b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceIpopt.html#ad77ec4132352c5093febf9c488a72a4c">Number</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIpopt_1_1LimMemQuasiNewtonUpdater.html#aef0116647ec48e237647d97ab4652d5b">last_eta_</a></td></tr>
<tr class="memdesc:aef0116647ec48e237647d97ab4652d5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Most recent value for eta in the restoration phase objective function (only for update_for_resto_ = true)  <a href="#aef0116647ec48e237647d97ab4652d5b">More...</a><br/></td></tr>
<tr class="separator:aef0116647ec48e237647d97ab4652d5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af91acff1d8121c05414463d5ff29c5a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIpopt_1_1SmartPtr.html">SmartPtr</a>&lt; const <a class="el" href="classIpopt_1_1Vector.html">Vector</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIpopt_1_1LimMemQuasiNewtonUpdater.html#af91acff1d8121c05414463d5ff29c5a3">curr_DR_x_</a></td></tr>
<tr class="memdesc:af91acff1d8121c05414463d5ff29c5a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Current DR_x scaling factors in the restoration phase objective function (only for update_for_resto_ = true).  <a href="#af91acff1d8121c05414463d5ff29c5a3">More...</a><br/></td></tr>
<tr class="separator:af91acff1d8121c05414463d5ff29c5a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d14331c82d5cb7136fcb6a224131cf1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIpopt_1_1TaggedObject.html#a6295578d16e7272fd040f02806d72afc">TaggedObject::Tag</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIpopt_1_1LimMemQuasiNewtonUpdater.html#a7d14331c82d5cb7136fcb6a224131cf1">curr_DR_x_tag_</a></td></tr>
<tr class="memdesc:a7d14331c82d5cb7136fcb6a224131cf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag for curr_DR_x_.  <a href="#a7d14331c82d5cb7136fcb6a224131cf1">More...</a><br/></td></tr>
<tr class="separator:a7d14331c82d5cb7136fcb6a224131cf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d1d56994acb3a1c934f4b73d96ffd3e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIpopt_1_1SmartPtr.html">SmartPtr</a>&lt; const <a class="el" href="classIpopt_1_1Vector.html">Vector</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIpopt_1_1LimMemQuasiNewtonUpdater.html#a5d1d56994acb3a1c934f4b73d96ffd3e">curr_red_DR_x_</a></td></tr>
<tr class="memdesc:a5d1d56994acb3a1c934f4b73d96ffd3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Current DR_x scaling factors in the restoration phase objective function in the smaller space for the approximation - this is only computed if the space is indeed smaller than the x space (only for update_for_resto_ = true)  <a href="#a5d1d56994acb3a1c934f4b73d96ffd3e">More...</a><br/></td></tr>
<tr class="separator:a5d1d56994acb3a1c934f4b73d96ffd3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a789105608badbec4cef9a15812443cbe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceIpopt.html#ad77ec4132352c5093febf9c488a72a4c">Number</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIpopt_1_1LimMemQuasiNewtonUpdater.html#a789105608badbec4cef9a15812443cbe">curr_eta_</a></td></tr>
<tr class="memdesc:a789105608badbec4cef9a15812443cbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Current value of weighing factor eta in the restoration phase objective function (only for update_for_resto_ = true)  <a href="#a789105608badbec4cef9a15812443cbe">More...</a><br/></td></tr>
<tr class="separator:a789105608badbec4cef9a15812443cbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f764363028359f79e527e895df21f1a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceIpopt.html#a8728e67558138991e8ee3fea451dca94">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIpopt_1_1LimMemQuasiNewtonUpdater.html#a0f764363028359f79e527e895df21f1a">lm_skipped_iter_</a></td></tr>
<tr class="memdesc:a0f764363028359f79e527e895df21f1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counter for successive iterations in which the update was skipped.  <a href="#a0f764363028359f79e527e895df21f1a">More...</a><br/></td></tr>
<tr class="separator:a0f764363028359f79e527e895df21f1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Information for the limited memory update</div></td></tr>
<tr class="memitem:ac6d2c7e8ceee3996c32041e7eb91bb89"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceIpopt.html#a8728e67558138991e8ee3fea451dca94">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIpopt_1_1LimMemQuasiNewtonUpdater.html#ac6d2c7e8ceee3996c32041e7eb91bb89">curr_lm_memory_</a></td></tr>
<tr class="memdesc:ac6d2c7e8ceee3996c32041e7eb91bb89"><td class="mdescLeft">&#160;</td><td class="mdescRight">current size of limited memory  <a href="#ac6d2c7e8ceee3996c32041e7eb91bb89">More...</a><br/></td></tr>
<tr class="separator:ac6d2c7e8ceee3996c32041e7eb91bb89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ebe9543568ffdbe356e98274b2fc3af"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIpopt_1_1SmartPtr.html">SmartPtr</a>&lt; <a class="el" href="classIpopt_1_1MultiVectorMatrix.html">MultiVectorMatrix</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIpopt_1_1LimMemQuasiNewtonUpdater.html#a2ebe9543568ffdbe356e98274b2fc3af">S_</a></td></tr>
<tr class="memdesc:a2ebe9543568ffdbe356e98274b2fc3af"><td class="mdescLeft">&#160;</td><td class="mdescRight">s pairs for the recent iterations  <a href="#a2ebe9543568ffdbe356e98274b2fc3af">More...</a><br/></td></tr>
<tr class="separator:a2ebe9543568ffdbe356e98274b2fc3af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae49f592101f43a0a489f37ef359c4195"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIpopt_1_1SmartPtr.html">SmartPtr</a>&lt; <a class="el" href="classIpopt_1_1MultiVectorMatrix.html">MultiVectorMatrix</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIpopt_1_1LimMemQuasiNewtonUpdater.html#ae49f592101f43a0a489f37ef359c4195">Y_</a></td></tr>
<tr class="memdesc:ae49f592101f43a0a489f37ef359c4195"><td class="mdescLeft">&#160;</td><td class="mdescRight">y pairs for the recent iterations.  <a href="#ae49f592101f43a0a489f37ef359c4195">More...</a><br/></td></tr>
<tr class="separator:ae49f592101f43a0a489f37ef359c4195"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4efc34f9ef1c16571408ffc1dcf72fc4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIpopt_1_1SmartPtr.html">SmartPtr</a>&lt; <a class="el" href="classIpopt_1_1MultiVectorMatrix.html">MultiVectorMatrix</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIpopt_1_1LimMemQuasiNewtonUpdater.html#a4efc34f9ef1c16571408ffc1dcf72fc4">Ypart_</a></td></tr>
<tr class="memdesc:a4efc34f9ef1c16571408ffc1dcf72fc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">For restoration phase update: Y without the quadratic objective function part.  <a href="#a4efc34f9ef1c16571408ffc1dcf72fc4">More...</a><br/></td></tr>
<tr class="separator:a4efc34f9ef1c16571408ffc1dcf72fc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b72dba39efe0d8d3bc8c0f0e5ab02f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIpopt_1_1SmartPtr.html">SmartPtr</a>&lt; <a class="el" href="classIpopt_1_1DenseVector.html">DenseVector</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIpopt_1_1LimMemQuasiNewtonUpdater.html#a9b72dba39efe0d8d3bc8c0f0e5ab02f1">D_</a></td></tr>
<tr class="memdesc:a9b72dba39efe0d8d3bc8c0f0e5ab02f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Diagonal elements D_k for compact formulation from last update.  <a href="#a9b72dba39efe0d8d3bc8c0f0e5ab02f1">More...</a><br/></td></tr>
<tr class="separator:a9b72dba39efe0d8d3bc8c0f0e5ab02f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3090910f99df48d7a85a634fe10a2e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIpopt_1_1SmartPtr.html">SmartPtr</a>&lt; <a class="el" href="classIpopt_1_1DenseGenMatrix.html">DenseGenMatrix</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIpopt_1_1LimMemQuasiNewtonUpdater.html#ac3090910f99df48d7a85a634fe10a2e6">L_</a></td></tr>
<tr class="memdesc:ac3090910f99df48d7a85a634fe10a2e6"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classIpopt_1_1Matrix.html" title="Matrix Base Class. ">Matrix</a> L_k for compact formulation from last update.  <a href="#ac3090910f99df48d7a85a634fe10a2e6">More...</a><br/></td></tr>
<tr class="separator:ac3090910f99df48d7a85a634fe10a2e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af787d841edfa76c8c1165f11dca07bce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIpopt_1_1SmartPtr.html">SmartPtr</a>&lt; <a class="el" href="classIpopt_1_1Vector.html">Vector</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIpopt_1_1LimMemQuasiNewtonUpdater.html#af787d841edfa76c8c1165f11dca07bce">B0_</a></td></tr>
<tr class="memdesc:af787d841edfa76c8c1165f11dca07bce"><td class="mdescLeft">&#160;</td><td class="mdescRight">First term (starting matrix) for the approximation.  <a href="#af787d841edfa76c8c1165f11dca07bce">More...</a><br/></td></tr>
<tr class="separator:af787d841edfa76c8c1165f11dca07bce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50a027bad36194279b6877357fd29e3c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceIpopt.html#ad77ec4132352c5093febf9c488a72a4c">Number</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIpopt_1_1LimMemQuasiNewtonUpdater.html#a50a027bad36194279b6877357fd29e3c">sigma_</a></td></tr>
<tr class="memdesc:a50a027bad36194279b6877357fd29e3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">First term (starting matrix) for the approximation.  <a href="#a50a027bad36194279b6877357fd29e3c">More...</a><br/></td></tr>
<tr class="separator:a50a027bad36194279b6877357fd29e3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f8b925b94d06ceccede4513b309d629"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIpopt_1_1SmartPtr.html">SmartPtr</a>&lt; <a class="el" href="classIpopt_1_1MultiVectorMatrix.html">MultiVectorMatrix</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIpopt_1_1LimMemQuasiNewtonUpdater.html#a7f8b925b94d06ceccede4513b309d629">V_</a></td></tr>
<tr class="memdesc:a7f8b925b94d06ceccede4513b309d629"><td class="mdescLeft">&#160;</td><td class="mdescRight">V in LowRankUpdateMatrix from last update.  <a href="#a7f8b925b94d06ceccede4513b309d629">More...</a><br/></td></tr>
<tr class="separator:a7f8b925b94d06ceccede4513b309d629"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69a2e525766120cdacc3cfbbdb502f34"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIpopt_1_1SmartPtr.html">SmartPtr</a>&lt; <a class="el" href="classIpopt_1_1MultiVectorMatrix.html">MultiVectorMatrix</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIpopt_1_1LimMemQuasiNewtonUpdater.html#a69a2e525766120cdacc3cfbbdb502f34">U_</a></td></tr>
<tr class="memdesc:a69a2e525766120cdacc3cfbbdb502f34"><td class="mdescLeft">&#160;</td><td class="mdescRight">U in LowRankUpdateMatrix from last update.  <a href="#a69a2e525766120cdacc3cfbbdb502f34">More...</a><br/></td></tr>
<tr class="separator:a69a2e525766120cdacc3cfbbdb502f34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fd9e1fe9182db0b989ad43d64702c68"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIpopt_1_1SmartPtr.html">SmartPtr</a>&lt; <a class="el" href="classIpopt_1_1DenseSymMatrix.html">DenseSymMatrix</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIpopt_1_1LimMemQuasiNewtonUpdater.html#a4fd9e1fe9182db0b989ad43d64702c68">SdotS_</a></td></tr>
<tr class="memdesc:a4fd9e1fe9182db0b989ad43d64702c68"><td class="mdescLeft">&#160;</td><td class="mdescRight">For efficient implementation, we store the pairwise products for s's.  <a href="#a4fd9e1fe9182db0b989ad43d64702c68">More...</a><br/></td></tr>
<tr class="separator:a4fd9e1fe9182db0b989ad43d64702c68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea28b939b4b61b5abd237fe996610d09"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIpopt_1_1LimMemQuasiNewtonUpdater.html#aea28b939b4b61b5abd237fe996610d09">SdotS_uptodate_</a></td></tr>
<tr class="memdesc:aea28b939b4b61b5abd237fe996610d09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag indicating whether SdotS_ is update to date from most recent update.  <a href="#aea28b939b4b61b5abd237fe996610d09">More...</a><br/></td></tr>
<tr class="separator:aea28b939b4b61b5abd237fe996610d09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1c6509f6a9dcc6f6ae478ad397a5ab1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIpopt_1_1SmartPtr.html">SmartPtr</a>&lt; <a class="el" href="classIpopt_1_1MultiVectorMatrix.html">MultiVectorMatrix</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIpopt_1_1LimMemQuasiNewtonUpdater.html#ae1c6509f6a9dcc6f6ae478ad397a5ab1">DRS_</a></td></tr>
<tr class="memdesc:ae1c6509f6a9dcc6f6ae478ad397a5ab1"><td class="mdescLeft">&#160;</td><td class="mdescRight">DR * S (only for restoration phase)  <a href="#ae1c6509f6a9dcc6f6ae478ad397a5ab1">More...</a><br/></td></tr>
<tr class="separator:ae1c6509f6a9dcc6f6ae478ad397a5ab1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05d855c245f0623a9aca28c3aa5ac14f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIpopt_1_1SmartPtr.html">SmartPtr</a>&lt; <a class="el" href="classIpopt_1_1DenseSymMatrix.html">DenseSymMatrix</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIpopt_1_1LimMemQuasiNewtonUpdater.html#a05d855c245f0623a9aca28c3aa5ac14f">STDRS_</a></td></tr>
<tr class="memdesc:a05d855c245f0623a9aca28c3aa5ac14f"><td class="mdescLeft">&#160;</td><td class="mdescRight">For efficient implementation, we store the S^T S DR * S.  <a href="#a05d855c245f0623a9aca28c3aa5ac14f">More...</a><br/></td></tr>
<tr class="separator:a05d855c245f0623a9aca28c3aa5ac14f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6c924d457bfb616a2f11e6129dc25a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIpopt_1_1SmartPtr.html">SmartPtr</a>&lt; const <a class="el" href="classIpopt_1_1Vector.html">Vector</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIpopt_1_1LimMemQuasiNewtonUpdater.html#ad6c924d457bfb616a2f11e6129dc25a1">last_x_</a></td></tr>
<tr class="memdesc:ad6c924d457bfb616a2f11e6129dc25a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Primal variables x from most recent update.  <a href="#ad6c924d457bfb616a2f11e6129dc25a1">More...</a><br/></td></tr>
<tr class="separator:ad6c924d457bfb616a2f11e6129dc25a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c01dfe9191fbd2bdae013541a07adf1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIpopt_1_1SmartPtr.html">SmartPtr</a>&lt; const <a class="el" href="classIpopt_1_1Vector.html">Vector</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIpopt_1_1LimMemQuasiNewtonUpdater.html#a8c01dfe9191fbd2bdae013541a07adf1">last_grad_f_</a></td></tr>
<tr class="memdesc:a8c01dfe9191fbd2bdae013541a07adf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gradient of objective function w.r.t.  <a href="#a8c01dfe9191fbd2bdae013541a07adf1">More...</a><br/></td></tr>
<tr class="separator:a8c01dfe9191fbd2bdae013541a07adf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b6ea6fbd20cbd6a907d2037727407d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIpopt_1_1SmartPtr.html">SmartPtr</a>&lt; const <a class="el" href="classIpopt_1_1Matrix.html">Matrix</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIpopt_1_1LimMemQuasiNewtonUpdater.html#a0b6ea6fbd20cbd6a907d2037727407d8">last_jac_c_</a></td></tr>
<tr class="memdesc:a0b6ea6fbd20cbd6a907d2037727407d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Jacobian for equality constraints w.r.t x at x_last.  <a href="#a0b6ea6fbd20cbd6a907d2037727407d8">More...</a><br/></td></tr>
<tr class="separator:a0b6ea6fbd20cbd6a907d2037727407d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39cde08934dec5c9d07ee60bd9f894dc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIpopt_1_1SmartPtr.html">SmartPtr</a>&lt; const <a class="el" href="classIpopt_1_1Matrix.html">Matrix</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIpopt_1_1LimMemQuasiNewtonUpdater.html#a39cde08934dec5c9d07ee60bd9f894dc">last_jac_d_</a></td></tr>
<tr class="memdesc:a39cde08934dec5c9d07ee60bd9f894dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Jacobian for inequality constraints w.r.t x at x_last.  <a href="#a39cde08934dec5c9d07ee60bd9f894dc">More...</a><br/></td></tr>
<tr class="separator:a39cde08934dec5c9d07ee60bd9f894dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af68441d4e1f531996c893ef537aefdd2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceIpopt.html#a8728e67558138991e8ee3fea451dca94">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIpopt_1_1LimMemQuasiNewtonUpdater.html#af68441d4e1f531996c893ef537aefdd2">curr_lm_memory_old_</a></td></tr>
<tr class="memdesc:af68441d4e1f531996c893ef537aefdd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">current size of limited memory  <a href="#af68441d4e1f531996c893ef537aefdd2">More...</a><br/></td></tr>
<tr class="separator:af68441d4e1f531996c893ef537aefdd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae39f3dcffe0149d85a578ecea3713ada"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIpopt_1_1SmartPtr.html">SmartPtr</a>&lt; <a class="el" href="classIpopt_1_1MultiVectorMatrix.html">MultiVectorMatrix</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIpopt_1_1LimMemQuasiNewtonUpdater.html#ae39f3dcffe0149d85a578ecea3713ada">S_old_</a></td></tr>
<tr class="memdesc:ae39f3dcffe0149d85a578ecea3713ada"><td class="mdescLeft">&#160;</td><td class="mdescRight">s pairs for the recent iterations (backup)  <a href="#ae39f3dcffe0149d85a578ecea3713ada">More...</a><br/></td></tr>
<tr class="separator:ae39f3dcffe0149d85a578ecea3713ada"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b3a8ff337019f44b57d51ef4ab768a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIpopt_1_1SmartPtr.html">SmartPtr</a>&lt; <a class="el" href="classIpopt_1_1MultiVectorMatrix.html">MultiVectorMatrix</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIpopt_1_1LimMemQuasiNewtonUpdater.html#a6b3a8ff337019f44b57d51ef4ab768a1">Y_old_</a></td></tr>
<tr class="memdesc:a6b3a8ff337019f44b57d51ef4ab768a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">y pairs for the recent iterations.  <a href="#a6b3a8ff337019f44b57d51ef4ab768a1">More...</a><br/></td></tr>
<tr class="separator:a6b3a8ff337019f44b57d51ef4ab768a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1234b1ef46ef754744118ed65474489a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIpopt_1_1SmartPtr.html">SmartPtr</a>&lt; <a class="el" href="classIpopt_1_1MultiVectorMatrix.html">MultiVectorMatrix</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIpopt_1_1LimMemQuasiNewtonUpdater.html#a1234b1ef46ef754744118ed65474489a">Ypart_old_</a></td></tr>
<tr class="memdesc:a1234b1ef46ef754744118ed65474489a"><td class="mdescLeft">&#160;</td><td class="mdescRight">For restoration phase update: Y without the quadratic objective function part (backup)  <a href="#a1234b1ef46ef754744118ed65474489a">More...</a><br/></td></tr>
<tr class="separator:a1234b1ef46ef754744118ed65474489a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b970b7904a109e21d61de28fd24f228"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIpopt_1_1SmartPtr.html">SmartPtr</a>&lt; <a class="el" href="classIpopt_1_1DenseVector.html">DenseVector</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIpopt_1_1LimMemQuasiNewtonUpdater.html#a6b970b7904a109e21d61de28fd24f228">D_old_</a></td></tr>
<tr class="memdesc:a6b970b7904a109e21d61de28fd24f228"><td class="mdescLeft">&#160;</td><td class="mdescRight">Diagonal elements D_k for compact formulation from last update (backup).  <a href="#a6b970b7904a109e21d61de28fd24f228">More...</a><br/></td></tr>
<tr class="separator:a6b970b7904a109e21d61de28fd24f228"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7bf7ad4de5fb03834605c0b30bcad00"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIpopt_1_1SmartPtr.html">SmartPtr</a>&lt; <a class="el" href="classIpopt_1_1DenseGenMatrix.html">DenseGenMatrix</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIpopt_1_1LimMemQuasiNewtonUpdater.html#ab7bf7ad4de5fb03834605c0b30bcad00">L_old_</a></td></tr>
<tr class="memdesc:ab7bf7ad4de5fb03834605c0b30bcad00"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classIpopt_1_1Matrix.html" title="Matrix Base Class. ">Matrix</a> L_k for compact formulation from last update (backup).  <a href="#ab7bf7ad4de5fb03834605c0b30bcad00">More...</a><br/></td></tr>
<tr class="separator:ab7bf7ad4de5fb03834605c0b30bcad00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7265d340c5f6d6e644d63377eec4b156"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIpopt_1_1SmartPtr.html">SmartPtr</a>&lt; <a class="el" href="classIpopt_1_1Vector.html">Vector</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIpopt_1_1LimMemQuasiNewtonUpdater.html#a7265d340c5f6d6e644d63377eec4b156">B0_old_</a></td></tr>
<tr class="memdesc:a7265d340c5f6d6e644d63377eec4b156"><td class="mdescLeft">&#160;</td><td class="mdescRight">First term (starting matrix) for the approximation (backup).  <a href="#a7265d340c5f6d6e644d63377eec4b156">More...</a><br/></td></tr>
<tr class="separator:a7265d340c5f6d6e644d63377eec4b156"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa17edd63f7905cec9abfa8d8d592009c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceIpopt.html#ad77ec4132352c5093febf9c488a72a4c">Number</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIpopt_1_1LimMemQuasiNewtonUpdater.html#aa17edd63f7905cec9abfa8d8d592009c">sigma_old_</a></td></tr>
<tr class="memdesc:aa17edd63f7905cec9abfa8d8d592009c"><td class="mdescLeft">&#160;</td><td class="mdescRight">First term (starting matrix) for the approximation.  <a href="#aa17edd63f7905cec9abfa8d8d592009c">More...</a><br/></td></tr>
<tr class="separator:aa17edd63f7905cec9abfa8d8d592009c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc1b44ee463310533e3412c274d134ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIpopt_1_1SmartPtr.html">SmartPtr</a>&lt; <a class="el" href="classIpopt_1_1MultiVectorMatrix.html">MultiVectorMatrix</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIpopt_1_1LimMemQuasiNewtonUpdater.html#afc1b44ee463310533e3412c274d134ed">V_old_</a></td></tr>
<tr class="memdesc:afc1b44ee463310533e3412c274d134ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">V in LowRankUpdateMatrix from last update (backup)  <a href="#afc1b44ee463310533e3412c274d134ed">More...</a><br/></td></tr>
<tr class="separator:afc1b44ee463310533e3412c274d134ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad98d84977d553282814871f362b61d52"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIpopt_1_1SmartPtr.html">SmartPtr</a>&lt; <a class="el" href="classIpopt_1_1MultiVectorMatrix.html">MultiVectorMatrix</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIpopt_1_1LimMemQuasiNewtonUpdater.html#ad98d84977d553282814871f362b61d52">U_old_</a></td></tr>
<tr class="memdesc:ad98d84977d553282814871f362b61d52"><td class="mdescLeft">&#160;</td><td class="mdescRight">U in LowRankUpdateMatrix from last update (backup)  <a href="#ad98d84977d553282814871f362b61d52">More...</a><br/></td></tr>
<tr class="separator:ad98d84977d553282814871f362b61d52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0687e0f7dda8f9a396c81435d0572137"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIpopt_1_1SmartPtr.html">SmartPtr</a>&lt; <a class="el" href="classIpopt_1_1DenseSymMatrix.html">DenseSymMatrix</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIpopt_1_1LimMemQuasiNewtonUpdater.html#a0687e0f7dda8f9a396c81435d0572137">SdotS_old_</a></td></tr>
<tr class="memdesc:a0687e0f7dda8f9a396c81435d0572137"><td class="mdescLeft">&#160;</td><td class="mdescRight">For efficient implementation, we store the pairwise products for s's (backup).  <a href="#a0687e0f7dda8f9a396c81435d0572137">More...</a><br/></td></tr>
<tr class="separator:a0687e0f7dda8f9a396c81435d0572137"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d0dec49277cc4359cdd40a8c4923ec2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIpopt_1_1LimMemQuasiNewtonUpdater.html#a6d0dec49277cc4359cdd40a8c4923ec2">SdotS_uptodate_old_</a></td></tr>
<tr class="memdesc:a6d0dec49277cc4359cdd40a8c4923ec2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag indicating whether SdotS_ is update to date from most recent update (backup).  <a href="#a6d0dec49277cc4359cdd40a8c4923ec2">More...</a><br/></td></tr>
<tr class="separator:a6d0dec49277cc4359cdd40a8c4923ec2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a2281c42f2dec342bf32ada3454815f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIpopt_1_1SmartPtr.html">SmartPtr</a>&lt; <a class="el" href="classIpopt_1_1MultiVectorMatrix.html">MultiVectorMatrix</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIpopt_1_1LimMemQuasiNewtonUpdater.html#a6a2281c42f2dec342bf32ada3454815f">DRS_old_</a></td></tr>
<tr class="memdesc:a6a2281c42f2dec342bf32ada3454815f"><td class="mdescLeft">&#160;</td><td class="mdescRight">DR * S (only for restoration phase) (backup)  <a href="#a6a2281c42f2dec342bf32ada3454815f">More...</a><br/></td></tr>
<tr class="separator:a6a2281c42f2dec342bf32ada3454815f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae13a4b50d8d9c7d22b115bc31e3c72c5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIpopt_1_1SmartPtr.html">SmartPtr</a>&lt; <a class="el" href="classIpopt_1_1DenseSymMatrix.html">DenseSymMatrix</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIpopt_1_1LimMemQuasiNewtonUpdater.html#ae13a4b50d8d9c7d22b115bc31e3c72c5">STDRS_old_</a></td></tr>
<tr class="memdesc:ae13a4b50d8d9c7d22b115bc31e3c72c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">For efficient implementation, we store the S^T S DR * S.  <a href="#ae13a4b50d8d9c7d22b115bc31e3c72c5">More...</a><br/></td></tr>
<tr class="separator:ae13a4b50d8d9c7d22b115bc31e3c72c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Algorithmic parameters</h2></td></tr>
<tr class="memitem:acf19d439cad539ceeb80509f92873ad4"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIpopt_1_1LimMemQuasiNewtonUpdater.html#acf19d439cad539ceeb80509f92873ad4">LMUpdateType</a> { <a class="el" href="classIpopt_1_1LimMemQuasiNewtonUpdater.html#acf19d439cad539ceeb80509f92873ad4a3c7d81b27fd76eabf23a156dc86ed0cb">BFGS</a> =0, 
<a class="el" href="classIpopt_1_1LimMemQuasiNewtonUpdater.html#acf19d439cad539ceeb80509f92873ad4a530dfa45ca122771541b83cdade376ef">SR1</a>
 }</td></tr>
<tr class="memdesc:acf19d439cad539ceeb80509f92873ad4"><td class="mdescLeft">&#160;</td><td class="mdescRight">enumeration for the Hessian update type.  <a href="classIpopt_1_1LimMemQuasiNewtonUpdater.html#acf19d439cad539ceeb80509f92873ad4">More...</a><br/></td></tr>
<tr class="separator:acf19d439cad539ceeb80509f92873ad4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84c23742ee6b01b50a0b1f82a5562dcc"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIpopt_1_1LimMemQuasiNewtonUpdater.html#a84c23742ee6b01b50a0b1f82a5562dcc">LMInitialization</a> { <br/>
&#160;&#160;<a class="el" href="classIpopt_1_1LimMemQuasiNewtonUpdater.html#a84c23742ee6b01b50a0b1f82a5562dccab999ac4ad4e475a440912a7ed9b611cd">SCALAR1</a> =0, 
<a class="el" href="classIpopt_1_1LimMemQuasiNewtonUpdater.html#a84c23742ee6b01b50a0b1f82a5562dcca35a685177867c1229b0ffcad5107783c">SCALAR2</a>, 
<a class="el" href="classIpopt_1_1LimMemQuasiNewtonUpdater.html#a84c23742ee6b01b50a0b1f82a5562dcca5556a24942d7ac00d1f8304f12098899">SCALAR3</a>, 
<a class="el" href="classIpopt_1_1LimMemQuasiNewtonUpdater.html#a84c23742ee6b01b50a0b1f82a5562dcca7264e878d1645f0329c6fc84807fdfe3">SCALAR4</a>, 
<br/>
&#160;&#160;<a class="el" href="classIpopt_1_1LimMemQuasiNewtonUpdater.html#a84c23742ee6b01b50a0b1f82a5562dccad78fb6e69e94d7572b89dab29c1842f1">CONSTANT</a>
<br/>
 }</td></tr>
<tr class="memdesc:a84c23742ee6b01b50a0b1f82a5562dcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">enumeration for the Hessian initialization.  <a href="classIpopt_1_1LimMemQuasiNewtonUpdater.html#a84c23742ee6b01b50a0b1f82a5562dcc">More...</a><br/></td></tr>
<tr class="separator:a84c23742ee6b01b50a0b1f82a5562dcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7691d300542e71170c22ad81e4239bcd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceIpopt.html#a8728e67558138991e8ee3fea451dca94">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIpopt_1_1LimMemQuasiNewtonUpdater.html#a7691d300542e71170c22ad81e4239bcd">limited_memory_max_history_</a></td></tr>
<tr class="memdesc:a7691d300542e71170c22ad81e4239bcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of memory for limited memory update.  <a href="#a7691d300542e71170c22ad81e4239bcd">More...</a><br/></td></tr>
<tr class="separator:a7691d300542e71170c22ad81e4239bcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac027f40e9a290f9a88c3e6762b919236"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIpopt_1_1LimMemQuasiNewtonUpdater.html#acf19d439cad539ceeb80509f92873ad4">LMUpdateType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIpopt_1_1LimMemQuasiNewtonUpdater.html#ac027f40e9a290f9a88c3e6762b919236">limited_memory_update_type_</a></td></tr>
<tr class="memdesc:ac027f40e9a290f9a88c3e6762b919236"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of Hessian update.  <a href="#ac027f40e9a290f9a88c3e6762b919236">More...</a><br/></td></tr>
<tr class="separator:ac027f40e9a290f9a88c3e6762b919236"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac2aa14e528872e28ca3d6604ba0efe2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIpopt_1_1LimMemQuasiNewtonUpdater.html#a84c23742ee6b01b50a0b1f82a5562dcc">LMInitialization</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIpopt_1_1LimMemQuasiNewtonUpdater.html#aac2aa14e528872e28ca3d6604ba0efe2">limited_memory_initialization_</a></td></tr>
<tr class="memdesc:aac2aa14e528872e28ca3d6604ba0efe2"><td class="mdescLeft">&#160;</td><td class="mdescRight">How to choose B0 in the low-rank update.  <a href="#aac2aa14e528872e28ca3d6604ba0efe2">More...</a><br/></td></tr>
<tr class="separator:aac2aa14e528872e28ca3d6604ba0efe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8b4466052e132ff9b7061da84207984"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceIpopt.html#ad77ec4132352c5093febf9c488a72a4c">Number</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIpopt_1_1LimMemQuasiNewtonUpdater.html#ae8b4466052e132ff9b7061da84207984">limited_memory_init_val_</a></td></tr>
<tr class="memdesc:ae8b4466052e132ff9b7061da84207984"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value of B0 (as this multiple of the identity in certain situations.)  <a href="#ae8b4466052e132ff9b7061da84207984">More...</a><br/></td></tr>
<tr class="separator:ae8b4466052e132ff9b7061da84207984"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0eafabd79b2d948ed4813cd3f31d057e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceIpopt.html#a8728e67558138991e8ee3fea451dca94">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIpopt_1_1LimMemQuasiNewtonUpdater.html#a0eafabd79b2d948ed4813cd3f31d057e">limited_memory_max_skipping_</a></td></tr>
<tr class="memdesc:a0eafabd79b2d948ed4813cd3f31d057e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of successive iterations of skipped updates after which the approximation is reset.  <a href="#a0eafabd79b2d948ed4813cd3f31d057e">More...</a><br/></td></tr>
<tr class="separator:a0eafabd79b2d948ed4813cd3f31d057e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fb9adbe06533616e20acfc2ca9c7290"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceIpopt.html#ad77ec4132352c5093febf9c488a72a4c">Number</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIpopt_1_1LimMemQuasiNewtonUpdater.html#a4fb9adbe06533616e20acfc2ca9c7290">sigma_safe_min_</a></td></tr>
<tr class="memdesc:a4fb9adbe06533616e20acfc2ca9c7290"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimal safeguard value for sigma.  <a href="#a4fb9adbe06533616e20acfc2ca9c7290">More...</a><br/></td></tr>
<tr class="separator:a4fb9adbe06533616e20acfc2ca9c7290"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d1969f74155d500554244b60f3a6d0e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceIpopt.html#ad77ec4132352c5093febf9c488a72a4c">Number</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIpopt_1_1LimMemQuasiNewtonUpdater.html#a7d1969f74155d500554244b60f3a6d0e">sigma_safe_max_</a></td></tr>
<tr class="memdesc:a7d1969f74155d500554244b60f3a6d0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximal safeguard value for sigma.  <a href="#a7d1969f74155d500554244b60f3a6d0e">More...</a><br/></td></tr>
<tr class="separator:a7d1969f74155d500554244b60f3a6d0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85614a07d4b5c236be90edb2c3f8ec96"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIpopt_1_1LimMemQuasiNewtonUpdater.html#a85614a07d4b5c236be90edb2c3f8ec96">limited_memory_special_for_resto_</a></td></tr>
<tr class="memdesc:a85614a07d4b5c236be90edb2c3f8ec96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag indicating if Hessian approximation should be done in a special manner for the restoration phase.  <a href="#a85614a07d4b5c236be90edb2c3f8ec96">More...</a><br/></td></tr>
<tr class="separator:a85614a07d4b5c236be90edb2c3f8ec96"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_methods_classIpopt_1_1AlgorithmStrategyObject"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classIpopt_1_1AlgorithmStrategyObject')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classIpopt_1_1AlgorithmStrategyObject.html">Ipopt::AlgorithmStrategyObject</a></td></tr>
<tr class="memitem:a2bdfc2fadc95782ede37ca7129541f3e inherit pro_methods_classIpopt_1_1AlgorithmStrategyObject"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classIpopt_1_1Journalist.html">Journalist</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIpopt_1_1AlgorithmStrategyObject.html#a2bdfc2fadc95782ede37ca7129541f3e">Jnlst</a> () const </td></tr>
<tr class="separator:a2bdfc2fadc95782ede37ca7129541f3e inherit pro_methods_classIpopt_1_1AlgorithmStrategyObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e7fe437b7b34faf758c9d330f3190d1 inherit pro_methods_classIpopt_1_1AlgorithmStrategyObject"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIpopt_1_1IpoptNLP.html">IpoptNLP</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIpopt_1_1AlgorithmStrategyObject.html#a0e7fe437b7b34faf758c9d330f3190d1">IpNLP</a> () const </td></tr>
<tr class="separator:a0e7fe437b7b34faf758c9d330f3190d1 inherit pro_methods_classIpopt_1_1AlgorithmStrategyObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13ff41c6682fa7bcab70b70352c8c9ea inherit pro_methods_classIpopt_1_1AlgorithmStrategyObject"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIpopt_1_1IpoptData.html">IpoptData</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIpopt_1_1AlgorithmStrategyObject.html#a13ff41c6682fa7bcab70b70352c8c9ea">IpData</a> () const </td></tr>
<tr class="separator:a13ff41c6682fa7bcab70b70352c8c9ea inherit pro_methods_classIpopt_1_1AlgorithmStrategyObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaafab9da1824170742f05b8241a139bb inherit pro_methods_classIpopt_1_1AlgorithmStrategyObject"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIpopt_1_1IpoptCalculatedQuantities.html">IpoptCalculatedQuantities</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIpopt_1_1AlgorithmStrategyObject.html#aaafab9da1824170742f05b8241a139bb">IpCq</a> () const </td></tr>
<tr class="separator:aaafab9da1824170742f05b8241a139bb inherit pro_methods_classIpopt_1_1AlgorithmStrategyObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7084ba2ebac159982889600c625711a1 inherit pro_methods_classIpopt_1_1AlgorithmStrategyObject"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIpopt_1_1AlgorithmStrategyObject.html#a7084ba2ebac159982889600c625711a1">HaveIpData</a> () const </td></tr>
<tr class="separator:a7084ba2ebac159982889600c625711a1 inherit pro_methods_classIpopt_1_1AlgorithmStrategyObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Implementation of the <a class="el" href="classIpopt_1_1HessianUpdater.html" title="Abstract base class for objects responsible for updating the Hessian information. ...">HessianUpdater</a> for limit-memory quasi-Newton approximation of the Lagrangian Hessian. </p>

<p>Definition at line <a class="el" href="IpLimMemQuasiNewtonUpdater_8hpp_source.html#l00025">25</a> of file <a class="el" href="IpLimMemQuasiNewtonUpdater_8hpp_source.html">IpLimMemQuasiNewtonUpdater.hpp</a>.</p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a class="anchor" id="acf19d439cad539ceeb80509f92873ad4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classIpopt_1_1LimMemQuasiNewtonUpdater.html#acf19d439cad539ceeb80509f92873ad4">Ipopt::LimMemQuasiNewtonUpdater::LMUpdateType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>enumeration for the Hessian update type. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="acf19d439cad539ceeb80509f92873ad4a3c7d81b27fd76eabf23a156dc86ed0cb"></a>BFGS</em>&nbsp;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="acf19d439cad539ceeb80509f92873ad4a530dfa45ca122771541b83cdade376ef"></a>SR1</em>&nbsp;</td><td class="fielddoc">
</td></tr>
</table>

<p>Definition at line <a class="el" href="IpLimMemQuasiNewtonUpdater_8hpp_source.html#l00075">75</a> of file <a class="el" href="IpLimMemQuasiNewtonUpdater_8hpp_source.html">IpLimMemQuasiNewtonUpdater.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a84c23742ee6b01b50a0b1f82a5562dcc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classIpopt_1_1LimMemQuasiNewtonUpdater.html#a84c23742ee6b01b50a0b1f82a5562dcc">Ipopt::LimMemQuasiNewtonUpdater::LMInitialization</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>enumeration for the Hessian initialization. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="a84c23742ee6b01b50a0b1f82a5562dccab999ac4ad4e475a440912a7ed9b611cd"></a>SCALAR1</em>&nbsp;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a84c23742ee6b01b50a0b1f82a5562dcca35a685177867c1229b0ffcad5107783c"></a>SCALAR2</em>&nbsp;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a84c23742ee6b01b50a0b1f82a5562dcca5556a24942d7ac00d1f8304f12098899"></a>SCALAR3</em>&nbsp;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a84c23742ee6b01b50a0b1f82a5562dcca7264e878d1645f0329c6fc84807fdfe3"></a>SCALAR4</em>&nbsp;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a84c23742ee6b01b50a0b1f82a5562dccad78fb6e69e94d7572b89dab29c1842f1"></a>CONSTANT</em>&nbsp;</td><td class="fielddoc">
</td></tr>
</table>

<p>Definition at line <a class="el" href="IpLimMemQuasiNewtonUpdater_8hpp_source.html#l00083">83</a> of file <a class="el" href="IpLimMemQuasiNewtonUpdater_8hpp_source.html">IpLimMemQuasiNewtonUpdater.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a8ea42c302bc7a9cd98835e06d1395449"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Ipopt::LimMemQuasiNewtonUpdater::LimMemQuasiNewtonUpdater </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>update_for_resto</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default Constructor. </p>

</div>
</div>
<a class="anchor" id="a965ff2daa98ef1e330111e5feef2f113"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Ipopt::LimMemQuasiNewtonUpdater::~LimMemQuasiNewtonUpdater </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default destructor. </p>

<p>Definition at line <a class="el" href="IpLimMemQuasiNewtonUpdater_8hpp_source.html#l00034">34</a> of file <a class="el" href="IpLimMemQuasiNewtonUpdater_8hpp_source.html">IpLimMemQuasiNewtonUpdater.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8529529ce958964fa629b4bb28ce5c76"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Ipopt::LimMemQuasiNewtonUpdater::LimMemQuasiNewtonUpdater </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIpopt_1_1LimMemQuasiNewtonUpdater.html">LimMemQuasiNewtonUpdater</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy Constructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ab6b064e5eff0e16c4aa83983070f20a6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Ipopt::LimMemQuasiNewtonUpdater::InitializeImpl </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIpopt_1_1OptionsList.html">OptionsList</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>prefix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>overloaded from <a class="el" href="classIpopt_1_1AlgorithmStrategyObject.html" title="This is the base class for all algorithm strategy objects. ">AlgorithmStrategyObject</a> </p>

<p>Implements <a class="el" href="classIpopt_1_1HessianUpdater.html#a703e4acf951f7fce479fb346dada6fc8">Ipopt::HessianUpdater</a>.</p>

</div>
</div>
<a class="anchor" id="a7a195f4bcb6d1c184068e69c97e4b206"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ipopt::LimMemQuasiNewtonUpdater::UpdateHessian </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update the Hessian based on the current information in IpData. </p>

<p>Implements <a class="el" href="classIpopt_1_1HessianUpdater.html#a4d00334fd4bdb03260e44b10dda85a33">Ipopt::HessianUpdater</a>.</p>

</div>
</div>
<a class="anchor" id="a3188133b8913b894c778ddc89d6c3dd2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Ipopt::LimMemQuasiNewtonUpdater::RegisterOptions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classIpopt_1_1SmartPtr.html">SmartPtr</a>&lt; <a class="el" href="classIpopt_1_1RegisteredOptions.html">RegisteredOptions</a> &gt;&#160;</td>
          <td class="paramname"><em>roptions</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Methods for <a class="el" href="classIpopt_1_1OptionsList.html" title="This class stores a list of user set options. ">OptionsList</a>. </p>

</div>
</div>
<a class="anchor" id="a4709f2080300a8151c009a5bf79f0873"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ipopt::LimMemQuasiNewtonUpdater::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIpopt_1_1LimMemQuasiNewtonUpdater.html">LimMemQuasiNewtonUpdater</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overloaded Equals Operator. </p>

</div>
</div>
<a class="anchor" id="a69c33a153dd61a75ba5e4748f3cd5fa6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ipopt::LimMemQuasiNewtonUpdater::CheckSkippingBFGS </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classIpopt_1_1Vector.html">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>s_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classIpopt_1_1Vector.html">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>y_new</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Method deciding whether the BFGS update should be skipped. </p>
<p>It returns true, if no update is to be performed this time. If Powell-damping is performed, the Vectors s_new and y_new, might be adapted. </p>

</div>
</div>
<a class="anchor" id="a4ea94f5ef65c96962c804c289085af51"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ipopt::LimMemQuasiNewtonUpdater::UpdateInternalData </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIpopt_1_1Vector.html">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>s_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIpopt_1_1Vector.html">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>y_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classIpopt_1_1SmartPtr.html">SmartPtr</a>&lt; <a class="el" href="classIpopt_1_1Vector.html">Vector</a> &gt;&#160;</td>
          <td class="paramname"><em>ypart_new</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update the internal data, such as the S, Y, L, D etc matrices and vectors that are required for computing the compact representation. </p>
<p>The method returns true if the limited memory history grew (i.e., curr_lm_memory_ was increased). </p>

</div>
</div>
<a class="anchor" id="a281068ccae8573fa1579f72a1130d8a7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ipopt::LimMemQuasiNewtonUpdater::AugmentMultiVector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classIpopt_1_1SmartPtr.html">SmartPtr</a>&lt; <a class="el" href="classIpopt_1_1MultiVectorMatrix.html">MultiVectorMatrix</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIpopt_1_1Vector.html">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>v_new</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a MutliVector V, create a new MultiVectorSpace with one more column, and return V as a member of that space, consisting of all previous vectors, and in addition v_new in the last column. </p>
<p>If V is NULL, then a new <a class="el" href="classIpopt_1_1MatrixSpace.html" title="MatrixSpace base class, corresponding to the Matrix base class. ">MatrixSpace</a> with one column is created. </p>

</div>
</div>
<a class="anchor" id="a3347d0c1aaf05f4cb0b0a1f1befeea36"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ipopt::LimMemQuasiNewtonUpdater::AugmentDenseVector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classIpopt_1_1SmartPtr.html">SmartPtr</a>&lt; <a class="el" href="classIpopt_1_1DenseVector.html">DenseVector</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceIpopt.html#ad77ec4132352c5093febf9c488a72a4c">Number</a>&#160;</td>
          <td class="paramname"><em>v_new</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a <a class="el" href="classIpopt_1_1DenseVector.html" title="Dense Vector Implementation. ">DenseVector</a> V, create a new <a class="el" href="classIpopt_1_1DenseVectorSpace.html" title="This vectors space is the vector space for DenseVector. ">DenseVectorSpace</a> with one more row, and return V as a member of that space, consisting of all previous elements, and in addition v_new in the last row. </p>
<p>If V is NULL, then a new <a class="el" href="classIpopt_1_1DenseVectorSpace.html" title="This vectors space is the vector space for DenseVector. ">DenseVectorSpace</a> with dimension one is created. </p>

</div>
</div>
<a class="anchor" id="aa89449bb9bffcc06bd6f723f97abc08c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ipopt::LimMemQuasiNewtonUpdater::AugmentLMatrix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classIpopt_1_1SmartPtr.html">SmartPtr</a>&lt; <a class="el" href="classIpopt_1_1DenseGenMatrix.html">DenseGenMatrix</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIpopt_1_1MultiVectorMatrix.html">MultiVectorMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIpopt_1_1MultiVectorMatrix.html">MultiVectorMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a strictly-lower triangular square <a class="el" href="classIpopt_1_1DenseGenMatrix.html" title="Class for dense general matrices. ">DenseGenMatrix</a> V, create a new <a class="el" href="classIpopt_1_1DenseGenMatrixSpace.html" title="This is the matrix space for DenseGenMatrix. ">DenseGenMatrixSpace</a> with one more dimension, and return V as a member of that space, consisting of all previous elements, and in addition elements s_i^Ty_j for (i&lt;j), where s and y are the vectors in the MultiVectors S and Y. </p>
<p>If V is NULL, then a new <a class="el" href="classIpopt_1_1DenseGenMatrixSpace.html" title="This is the matrix space for DenseGenMatrix. ">DenseGenMatrixSpace</a> with dimension one is created. </p>

</div>
</div>
<a class="anchor" id="ab25f342f56b53a2dc86368f20140bd36"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ipopt::LimMemQuasiNewtonUpdater::AugmentSdotSMatrix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classIpopt_1_1SmartPtr.html">SmartPtr</a>&lt; <a class="el" href="classIpopt_1_1DenseSymMatrix.html">DenseSymMatrix</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIpopt_1_1MultiVectorMatrix.html">MultiVectorMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>S</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a <a class="el" href="classIpopt_1_1DenseSymMatrix.html" title="Class for dense symetrix matrices. ">DenseSymMatrix</a> V, create a new <a class="el" href="classIpopt_1_1DenseGenMatrixSpace.html" title="This is the matrix space for DenseGenMatrix. ">DenseGenMatrixSpace</a> with one more dimension, and return V as a member of that space, consisting of all previous elements, and in addition elements s_i^Ts_j for the new entries, where s are the vectors in the MultiVector S. </p>
<p>If V is NULL, then a new <a class="el" href="classIpopt_1_1DenseGenMatrixSpace.html" title="This is the matrix space for DenseGenMatrix. ">DenseGenMatrixSpace</a> with dimension one is created. </p>

</div>
</div>
<a class="anchor" id="a03996ca8af26c62753acf1802f9df486"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ipopt::LimMemQuasiNewtonUpdater::AugmentSTDRSMatrix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classIpopt_1_1SmartPtr.html">SmartPtr</a>&lt; <a class="el" href="classIpopt_1_1DenseSymMatrix.html">DenseSymMatrix</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIpopt_1_1MultiVectorMatrix.html">MultiVectorMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIpopt_1_1MultiVectorMatrix.html">MultiVectorMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>DRS</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a <a class="el" href="classIpopt_1_1DenseSymMatrix.html" title="Class for dense symetrix matrices. ">DenseSymMatrix</a> V, create a new <a class="el" href="classIpopt_1_1DenseGenMatrixSpace.html" title="This is the matrix space for DenseGenMatrix. ">DenseGenMatrixSpace</a> with one more dimension, and return V as a member of that space, consisting of all previous elements, and in addition elements s_i^TDRs_j for the new entries, where s are the vectors in the MultiVector S, and DRs are the vectors in DRS. </p>
<p>If V is NULL, then a new <a class="el" href="classIpopt_1_1DenseGenMatrixSpace.html" title="This is the matrix space for DenseGenMatrix. ">DenseGenMatrixSpace</a> with dimension one is created. </p>

</div>
</div>
<a class="anchor" id="ac93aefcf009ce32ab2821b8e5b296d88"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ipopt::LimMemQuasiNewtonUpdater::ShiftMultiVector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classIpopt_1_1SmartPtr.html">SmartPtr</a>&lt; <a class="el" href="classIpopt_1_1MultiVectorMatrix.html">MultiVectorMatrix</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIpopt_1_1Vector.html">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>v_new</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a MutliVector V, get rid of the first column, shift all other columns to the left, and make v_new the last column. </p>
<p>The entity that V points to at the call, is not changed - a new entity is created in the method and returned as V. </p>

</div>
</div>
<a class="anchor" id="a01a1da7d35c0fd842db33fad7c931da1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ipopt::LimMemQuasiNewtonUpdater::ShiftDenseVector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classIpopt_1_1SmartPtr.html">SmartPtr</a>&lt; <a class="el" href="classIpopt_1_1DenseVector.html">DenseVector</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceIpopt.html#ad77ec4132352c5093febf9c488a72a4c">Number</a>&#160;</td>
          <td class="paramname"><em>v_new</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a <a class="el" href="classIpopt_1_1DenseVector.html" title="Dense Vector Implementation. ">DenseVector</a> V, get rid of the first element, shift all other elements one position to the top, and make v_new the last entry. </p>
<p>The entity that V points to at the call, is not changed - a new entity is created in the method and returned as V. </p>

</div>
</div>
<a class="anchor" id="a4d80493f4d0f2ce08ac61bd0c6d97821"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ipopt::LimMemQuasiNewtonUpdater::ShiftLMatrix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classIpopt_1_1SmartPtr.html">SmartPtr</a>&lt; <a class="el" href="classIpopt_1_1DenseGenMatrix.html">DenseGenMatrix</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIpopt_1_1MultiVectorMatrix.html">MultiVectorMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIpopt_1_1MultiVectorMatrix.html">MultiVectorMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a strictly-lower triangular square <a class="el" href="classIpopt_1_1DenseGenMatrix.html" title="Class for dense general matrices. ">DenseGenMatrix</a> V, shift everything one row and column up, and fill the new strictly lower triangular entries as s_i^Ty_j for (i&lt;j), where s and y are the vectors in the MultiVectors S and Y. </p>
<p>The entity that V points to at the call, is not changed - a new entity is created in the method and returned as V. </p>

</div>
</div>
<a class="anchor" id="a30e0b5e73c9c3a90db01980aac74a8e6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ipopt::LimMemQuasiNewtonUpdater::ShiftSdotSMatrix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classIpopt_1_1SmartPtr.html">SmartPtr</a>&lt; <a class="el" href="classIpopt_1_1DenseSymMatrix.html">DenseSymMatrix</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIpopt_1_1MultiVectorMatrix.html">MultiVectorMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>S</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a <a class="el" href="classIpopt_1_1DenseSymMatrix.html" title="Class for dense symetrix matrices. ">DenseSymMatrix</a> V, shift everything up one row and column, and fill the new entries as s_i^Ts_j, where s are the vectors in the MultiVector S. </p>
<p>The entity that V points to at the call, is not changed - a new entity is created in the method and returned as V. </p>

</div>
</div>
<a class="anchor" id="a7aaf1c9d5d6b97fbed3af013aa1d3667"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ipopt::LimMemQuasiNewtonUpdater::ShiftSTDRSMatrix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classIpopt_1_1SmartPtr.html">SmartPtr</a>&lt; <a class="el" href="classIpopt_1_1DenseSymMatrix.html">DenseSymMatrix</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIpopt_1_1MultiVectorMatrix.html">MultiVectorMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIpopt_1_1MultiVectorMatrix.html">MultiVectorMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>DRS</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a <a class="el" href="classIpopt_1_1DenseSymMatrix.html" title="Class for dense symetrix matrices. ">DenseSymMatrix</a> V, shift everything up one row and column, and fill the new entries as s_i^TDRs_j, where s are the vectors in the MultiVector S, and DRs are the vectors in DRS. </p>
<p>The entity that V points to at the call, is not changed - a new entity is created in the method and returned as V. </p>

</div>
</div>
<a class="anchor" id="a9ad1d47e72181bb14902c63acc4bc421"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ipopt::LimMemQuasiNewtonUpdater::RecalcY </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceIpopt.html#ad77ec4132352c5093febf9c488a72a4c">Number</a>&#160;</td>
          <td class="paramname"><em>eta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIpopt_1_1Vector.html">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>DR_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classIpopt_1_1MultiVectorMatrix.html">MultiVectorMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classIpopt_1_1MultiVectorMatrix.html">MultiVectorMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>Ypart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classIpopt_1_1SmartPtr.html">SmartPtr</a>&lt; <a class="el" href="classIpopt_1_1MultiVectorMatrix.html">MultiVectorMatrix</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Method for recomputing Y from scratch, using Ypart (only for restoration phase) </p>

</div>
</div>
<a class="anchor" id="add79a0ddc6922b9859c2a40e0731d980"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ipopt::LimMemQuasiNewtonUpdater::RecalcD </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classIpopt_1_1MultiVectorMatrix.html">MultiVectorMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classIpopt_1_1MultiVectorMatrix.html">MultiVectorMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>Y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classIpopt_1_1SmartPtr.html">SmartPtr</a>&lt; <a class="el" href="classIpopt_1_1DenseVector.html">DenseVector</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>D</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Method for recomputing D from S and Y. </p>

</div>
</div>
<a class="anchor" id="af74064858a0134506188b8858d3f697b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ipopt::LimMemQuasiNewtonUpdater::RecalcL </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classIpopt_1_1MultiVectorMatrix.html">MultiVectorMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classIpopt_1_1MultiVectorMatrix.html">MultiVectorMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>Y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classIpopt_1_1SmartPtr.html">SmartPtr</a>&lt; <a class="el" href="classIpopt_1_1DenseGenMatrix.html">DenseGenMatrix</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>L</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Method for recomputing L from S and Y. </p>

</div>
</div>
<a class="anchor" id="a4b1dfddf4b1e8a0ea7495e6fc6aaaf97"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ipopt::LimMemQuasiNewtonUpdater::SplitEigenvalues </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classIpopt_1_1DenseGenMatrix.html">DenseGenMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIpopt_1_1DenseVector.html">DenseVector</a> &amp;&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classIpopt_1_1SmartPtr.html">SmartPtr</a>&lt; <a class="el" href="classIpopt_1_1DenseGenMatrix.html">DenseGenMatrix</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>Qminus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classIpopt_1_1SmartPtr.html">SmartPtr</a>&lt; <a class="el" href="classIpopt_1_1DenseGenMatrix.html">DenseGenMatrix</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>Qplus</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Split the eigenvectors into negative and positive ones. </p>
<p>Given the eigenvectors in Q and the eigenvalues (in ascending order) in, this returns Qminus as the negative eigenvectors times sqrt(-eval), and Qplus as the positive eigenvectors times sqrt(eval). If Qminus or Qplus is NULL, it means that there are not negetive or positive eigenvalues. Q might be changed during this call. The return value is true, if the ratio of the smallest over the largest eigenvalue (in absolute values) is too small; in that case, the update should be skipped. </p>

</div>
</div>
<a class="anchor" id="a0173e5e0e256e7ad2a8cff90a8fb6c37"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ipopt::LimMemQuasiNewtonUpdater::StoreInternalDataBackup </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Store a copy of the pointers to the internal data (S, Y, D, L, SdotS, curr_lm_memory) This is called in case the update is started but skipped during the process. </p>

</div>
</div>
<a class="anchor" id="a8e7c02278b58807cd441410d983e3fd0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ipopt::LimMemQuasiNewtonUpdater::RestoreInternalDataBackup </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Restore the copy of the pointers to the internal data most recently stored with <a class="el" href="classIpopt_1_1LimMemQuasiNewtonUpdater.html#a0173e5e0e256e7ad2a8cff90a8fb6c37" title="Store a copy of the pointers to the internal data (S, Y, D, L, SdotS, curr_lm_memory) This is called ...">StoreInternalDataBackup()</a>. </p>

</div>
</div>
<a class="anchor" id="a366a223055bf23936869c68d40ae2c4d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ipopt::LimMemQuasiNewtonUpdater::ReleaseInternalDataBackup </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Release anything that we allocated for StoreInternalDataBackup and is no longer needed. </p>

</div>
</div>
<a class="anchor" id="a54a308c4b7b42628732d0fbf4b9081da"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ipopt::LimMemQuasiNewtonUpdater::SetW </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the W field in IpData based on the current values of B0_, V_, and U_. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="ae651bfdde2b4bb371616d5427f474d92"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIpopt_1_1SmartPtr.html">SmartPtr</a>&lt;const <a class="el" href="classIpopt_1_1LowRankUpdateSymMatrixSpace.html">LowRankUpdateSymMatrixSpace</a>&gt; Ipopt::LimMemQuasiNewtonUpdater::h_space_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classIpopt_1_1Matrix.html" title="Matrix Base Class. ">Matrix</a> space for the low-rank Hessian approximation. </p>

<p>Definition at line <a class="el" href="IpLimMemQuasiNewtonUpdater_8hpp_source.html#l00068">68</a> of file <a class="el" href="IpLimMemQuasiNewtonUpdater_8hpp_source.html">IpLimMemQuasiNewtonUpdater.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7691d300542e71170c22ad81e4239bcd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceIpopt.html#a8728e67558138991e8ee3fea451dca94">Index</a> Ipopt::LimMemQuasiNewtonUpdater::limited_memory_max_history_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Size of memory for limited memory update. </p>

<p>Definition at line <a class="el" href="IpLimMemQuasiNewtonUpdater_8hpp_source.html#l00073">73</a> of file <a class="el" href="IpLimMemQuasiNewtonUpdater_8hpp_source.html">IpLimMemQuasiNewtonUpdater.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac027f40e9a290f9a88c3e6762b919236"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIpopt_1_1LimMemQuasiNewtonUpdater.html#acf19d439cad539ceeb80509f92873ad4">LMUpdateType</a> Ipopt::LimMemQuasiNewtonUpdater::limited_memory_update_type_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Type of Hessian update. </p>

<p>Definition at line <a class="el" href="IpLimMemQuasiNewtonUpdater_8hpp_source.html#l00081">81</a> of file <a class="el" href="IpLimMemQuasiNewtonUpdater_8hpp_source.html">IpLimMemQuasiNewtonUpdater.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aac2aa14e528872e28ca3d6604ba0efe2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIpopt_1_1LimMemQuasiNewtonUpdater.html#a84c23742ee6b01b50a0b1f82a5562dcc">LMInitialization</a> Ipopt::LimMemQuasiNewtonUpdater::limited_memory_initialization_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>How to choose B0 in the low-rank update. </p>

<p>Definition at line <a class="el" href="IpLimMemQuasiNewtonUpdater_8hpp_source.html#l00092">92</a> of file <a class="el" href="IpLimMemQuasiNewtonUpdater_8hpp_source.html">IpLimMemQuasiNewtonUpdater.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae8b4466052e132ff9b7061da84207984"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceIpopt.html#ad77ec4132352c5093febf9c488a72a4c">Number</a> Ipopt::LimMemQuasiNewtonUpdater::limited_memory_init_val_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Value of B0 (as this multiple of the identity in certain situations.) </p>

<p>Definition at line <a class="el" href="IpLimMemQuasiNewtonUpdater_8hpp_source.html#l00095">95</a> of file <a class="el" href="IpLimMemQuasiNewtonUpdater_8hpp_source.html">IpLimMemQuasiNewtonUpdater.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0eafabd79b2d948ed4813cd3f31d057e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceIpopt.html#a8728e67558138991e8ee3fea451dca94">Index</a> Ipopt::LimMemQuasiNewtonUpdater::limited_memory_max_skipping_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of successive iterations of skipped updates after which the approximation is reset. </p>

<p>Definition at line <a class="el" href="IpLimMemQuasiNewtonUpdater_8hpp_source.html#l00098">98</a> of file <a class="el" href="IpLimMemQuasiNewtonUpdater_8hpp_source.html">IpLimMemQuasiNewtonUpdater.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4fb9adbe06533616e20acfc2ca9c7290"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceIpopt.html#ad77ec4132352c5093febf9c488a72a4c">Number</a> Ipopt::LimMemQuasiNewtonUpdater::sigma_safe_min_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Minimal safeguard value for sigma. </p>

<p>Definition at line <a class="el" href="IpLimMemQuasiNewtonUpdater_8hpp_source.html#l00100">100</a> of file <a class="el" href="IpLimMemQuasiNewtonUpdater_8hpp_source.html">IpLimMemQuasiNewtonUpdater.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7d1969f74155d500554244b60f3a6d0e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceIpopt.html#ad77ec4132352c5093febf9c488a72a4c">Number</a> Ipopt::LimMemQuasiNewtonUpdater::sigma_safe_max_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maximal safeguard value for sigma. </p>

<p>Definition at line <a class="el" href="IpLimMemQuasiNewtonUpdater_8hpp_source.html#l00102">102</a> of file <a class="el" href="IpLimMemQuasiNewtonUpdater_8hpp_source.html">IpLimMemQuasiNewtonUpdater.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a85614a07d4b5c236be90edb2c3f8ec96"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ipopt::LimMemQuasiNewtonUpdater::limited_memory_special_for_resto_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Flag indicating if Hessian approximation should be done in a special manner for the restoration phase. </p>

<p>Definition at line <a class="el" href="IpLimMemQuasiNewtonUpdater_8hpp_source.html#l00105">105</a> of file <a class="el" href="IpLimMemQuasiNewtonUpdater_8hpp_source.html">IpLimMemQuasiNewtonUpdater.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5bf884f069d635a28721132018e82408"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const bool Ipopt::LimMemQuasiNewtonUpdater::update_for_resto_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Flag indicating if the update is to be done for the original <a class="el" href="classIpopt_1_1NLP.html" title="Brief Class Description. ">NLP</a> or for the restoration phase <a class="el" href="classIpopt_1_1NLP.html" title="Brief Class Description. ">NLP</a>. </p>
<p>In the latter case, we are performing a "structured" update, taking into account the first explicit term in the objective function of the form eta*D_r*x_k </p>

<p>Definition at line <a class="el" href="IpLimMemQuasiNewtonUpdater_8hpp_source.html#l00113">113</a> of file <a class="el" href="IpLimMemQuasiNewtonUpdater_8hpp_source.html">IpLimMemQuasiNewtonUpdater.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aef0116647ec48e237647d97ab4652d5b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceIpopt.html#ad77ec4132352c5093febf9c488a72a4c">Number</a> Ipopt::LimMemQuasiNewtonUpdater::last_eta_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Most recent value for eta in the restoration phase objective function (only for update_for_resto_ = true) </p>

<p>Definition at line <a class="el" href="IpLimMemQuasiNewtonUpdater_8hpp_source.html#l00116">116</a> of file <a class="el" href="IpLimMemQuasiNewtonUpdater_8hpp_source.html">IpLimMemQuasiNewtonUpdater.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af91acff1d8121c05414463d5ff29c5a3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIpopt_1_1SmartPtr.html">SmartPtr</a>&lt;const <a class="el" href="classIpopt_1_1Vector.html">Vector</a>&gt; Ipopt::LimMemQuasiNewtonUpdater::curr_DR_x_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Current DR_x scaling factors in the restoration phase objective function (only for update_for_resto_ = true). </p>
<p>This should not change throughout one restoration phase. </p>

<p>Definition at line <a class="el" href="IpLimMemQuasiNewtonUpdater_8hpp_source.html#l00120">120</a> of file <a class="el" href="IpLimMemQuasiNewtonUpdater_8hpp_source.html">IpLimMemQuasiNewtonUpdater.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7d14331c82d5cb7136fcb6a224131cf1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIpopt_1_1TaggedObject.html#a6295578d16e7272fd040f02806d72afc">TaggedObject::Tag</a> Ipopt::LimMemQuasiNewtonUpdater::curr_DR_x_tag_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tag for curr_DR_x_. </p>

<p>Definition at line <a class="el" href="IpLimMemQuasiNewtonUpdater_8hpp_source.html#l00122">122</a> of file <a class="el" href="IpLimMemQuasiNewtonUpdater_8hpp_source.html">IpLimMemQuasiNewtonUpdater.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5d1d56994acb3a1c934f4b73d96ffd3e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIpopt_1_1SmartPtr.html">SmartPtr</a>&lt;const <a class="el" href="classIpopt_1_1Vector.html">Vector</a>&gt; Ipopt::LimMemQuasiNewtonUpdater::curr_red_DR_x_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Current DR_x scaling factors in the restoration phase objective function in the smaller space for the approximation - this is only computed if the space is indeed smaller than the x space (only for update_for_resto_ = true) </p>

<p>Definition at line <a class="el" href="IpLimMemQuasiNewtonUpdater_8hpp_source.html#l00127">127</a> of file <a class="el" href="IpLimMemQuasiNewtonUpdater_8hpp_source.html">IpLimMemQuasiNewtonUpdater.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a789105608badbec4cef9a15812443cbe"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceIpopt.html#ad77ec4132352c5093febf9c488a72a4c">Number</a> Ipopt::LimMemQuasiNewtonUpdater::curr_eta_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Current value of weighing factor eta in the restoration phase objective function (only for update_for_resto_ = true) </p>

<p>Definition at line <a class="el" href="IpLimMemQuasiNewtonUpdater_8hpp_source.html#l00130">130</a> of file <a class="el" href="IpLimMemQuasiNewtonUpdater_8hpp_source.html">IpLimMemQuasiNewtonUpdater.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0f764363028359f79e527e895df21f1a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceIpopt.html#a8728e67558138991e8ee3fea451dca94">Index</a> Ipopt::LimMemQuasiNewtonUpdater::lm_skipped_iter_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Counter for successive iterations in which the update was skipped. </p>

<p>Definition at line <a class="el" href="IpLimMemQuasiNewtonUpdater_8hpp_source.html#l00134">134</a> of file <a class="el" href="IpLimMemQuasiNewtonUpdater_8hpp_source.html">IpLimMemQuasiNewtonUpdater.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac6d2c7e8ceee3996c32041e7eb91bb89"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceIpopt.html#a8728e67558138991e8ee3fea451dca94">Index</a> Ipopt::LimMemQuasiNewtonUpdater::curr_lm_memory_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>current size of limited memory </p>

<p>Definition at line <a class="el" href="IpLimMemQuasiNewtonUpdater_8hpp_source.html#l00139">139</a> of file <a class="el" href="IpLimMemQuasiNewtonUpdater_8hpp_source.html">IpLimMemQuasiNewtonUpdater.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2ebe9543568ffdbe356e98274b2fc3af"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIpopt_1_1SmartPtr.html">SmartPtr</a>&lt;<a class="el" href="classIpopt_1_1MultiVectorMatrix.html">MultiVectorMatrix</a>&gt; Ipopt::LimMemQuasiNewtonUpdater::S_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>s pairs for the recent iterations </p>

<p>Definition at line <a class="el" href="IpLimMemQuasiNewtonUpdater_8hpp_source.html#l00141">141</a> of file <a class="el" href="IpLimMemQuasiNewtonUpdater_8hpp_source.html">IpLimMemQuasiNewtonUpdater.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae49f592101f43a0a489f37ef359c4195"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIpopt_1_1SmartPtr.html">SmartPtr</a>&lt;<a class="el" href="classIpopt_1_1MultiVectorMatrix.html">MultiVectorMatrix</a>&gt; Ipopt::LimMemQuasiNewtonUpdater::Y_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>y pairs for the recent iterations. </p>
<p>If update_for_resto is true, then this includes only the information for the constraints. </p>

<p>Definition at line <a class="el" href="IpLimMemQuasiNewtonUpdater_8hpp_source.html#l00145">145</a> of file <a class="el" href="IpLimMemQuasiNewtonUpdater_8hpp_source.html">IpLimMemQuasiNewtonUpdater.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4efc34f9ef1c16571408ffc1dcf72fc4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIpopt_1_1SmartPtr.html">SmartPtr</a>&lt;<a class="el" href="classIpopt_1_1MultiVectorMatrix.html">MultiVectorMatrix</a>&gt; Ipopt::LimMemQuasiNewtonUpdater::Ypart_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For restoration phase update: Y without the quadratic objective function part. </p>

<p>Definition at line <a class="el" href="IpLimMemQuasiNewtonUpdater_8hpp_source.html#l00148">148</a> of file <a class="el" href="IpLimMemQuasiNewtonUpdater_8hpp_source.html">IpLimMemQuasiNewtonUpdater.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9b72dba39efe0d8d3bc8c0f0e5ab02f1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIpopt_1_1SmartPtr.html">SmartPtr</a>&lt;<a class="el" href="classIpopt_1_1DenseVector.html">DenseVector</a>&gt; Ipopt::LimMemQuasiNewtonUpdater::D_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Diagonal elements D_k for compact formulation from last update. </p>

<p>Definition at line <a class="el" href="IpLimMemQuasiNewtonUpdater_8hpp_source.html#l00151">151</a> of file <a class="el" href="IpLimMemQuasiNewtonUpdater_8hpp_source.html">IpLimMemQuasiNewtonUpdater.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac3090910f99df48d7a85a634fe10a2e6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIpopt_1_1SmartPtr.html">SmartPtr</a>&lt;<a class="el" href="classIpopt_1_1DenseGenMatrix.html">DenseGenMatrix</a>&gt; Ipopt::LimMemQuasiNewtonUpdater::L_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classIpopt_1_1Matrix.html" title="Matrix Base Class. ">Matrix</a> L_k for compact formulation from last update. </p>

<p>Definition at line <a class="el" href="IpLimMemQuasiNewtonUpdater_8hpp_source.html#l00153">153</a> of file <a class="el" href="IpLimMemQuasiNewtonUpdater_8hpp_source.html">IpLimMemQuasiNewtonUpdater.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af787d841edfa76c8c1165f11dca07bce"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIpopt_1_1SmartPtr.html">SmartPtr</a>&lt;<a class="el" href="classIpopt_1_1Vector.html">Vector</a>&gt; Ipopt::LimMemQuasiNewtonUpdater::B0_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>First term (starting matrix) for the approximation. </p>

<p>Definition at line <a class="el" href="IpLimMemQuasiNewtonUpdater_8hpp_source.html#l00155">155</a> of file <a class="el" href="IpLimMemQuasiNewtonUpdater_8hpp_source.html">IpLimMemQuasiNewtonUpdater.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a50a027bad36194279b6877357fd29e3c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceIpopt.html#ad77ec4132352c5093febf9c488a72a4c">Number</a> Ipopt::LimMemQuasiNewtonUpdater::sigma_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>First term (starting matrix) for the approximation. </p>
<p>If that first terms is a multiple of the identy, sigma give that factor. Otherwise sigma = -1. </p>

<p>Definition at line <a class="el" href="IpLimMemQuasiNewtonUpdater_8hpp_source.html#l00159">159</a> of file <a class="el" href="IpLimMemQuasiNewtonUpdater_8hpp_source.html">IpLimMemQuasiNewtonUpdater.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7f8b925b94d06ceccede4513b309d629"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIpopt_1_1SmartPtr.html">SmartPtr</a>&lt;<a class="el" href="classIpopt_1_1MultiVectorMatrix.html">MultiVectorMatrix</a>&gt; Ipopt::LimMemQuasiNewtonUpdater::V_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>V in LowRankUpdateMatrix from last update. </p>

<p>Definition at line <a class="el" href="IpLimMemQuasiNewtonUpdater_8hpp_source.html#l00161">161</a> of file <a class="el" href="IpLimMemQuasiNewtonUpdater_8hpp_source.html">IpLimMemQuasiNewtonUpdater.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a69a2e525766120cdacc3cfbbdb502f34"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIpopt_1_1SmartPtr.html">SmartPtr</a>&lt;<a class="el" href="classIpopt_1_1MultiVectorMatrix.html">MultiVectorMatrix</a>&gt; Ipopt::LimMemQuasiNewtonUpdater::U_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>U in LowRankUpdateMatrix from last update. </p>

<p>Definition at line <a class="el" href="IpLimMemQuasiNewtonUpdater_8hpp_source.html#l00163">163</a> of file <a class="el" href="IpLimMemQuasiNewtonUpdater_8hpp_source.html">IpLimMemQuasiNewtonUpdater.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4fd9e1fe9182db0b989ad43d64702c68"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIpopt_1_1SmartPtr.html">SmartPtr</a>&lt;<a class="el" href="classIpopt_1_1DenseSymMatrix.html">DenseSymMatrix</a>&gt; Ipopt::LimMemQuasiNewtonUpdater::SdotS_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For efficient implementation, we store the pairwise products for s's. </p>

<p>Definition at line <a class="el" href="IpLimMemQuasiNewtonUpdater_8hpp_source.html#l00166">166</a> of file <a class="el" href="IpLimMemQuasiNewtonUpdater_8hpp_source.html">IpLimMemQuasiNewtonUpdater.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aea28b939b4b61b5abd237fe996610d09"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ipopt::LimMemQuasiNewtonUpdater::SdotS_uptodate_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Flag indicating whether SdotS_ is update to date from most recent update. </p>

<p>Definition at line <a class="el" href="IpLimMemQuasiNewtonUpdater_8hpp_source.html#l00169">169</a> of file <a class="el" href="IpLimMemQuasiNewtonUpdater_8hpp_source.html">IpLimMemQuasiNewtonUpdater.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae1c6509f6a9dcc6f6ae478ad397a5ab1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIpopt_1_1SmartPtr.html">SmartPtr</a>&lt;<a class="el" href="classIpopt_1_1MultiVectorMatrix.html">MultiVectorMatrix</a>&gt; Ipopt::LimMemQuasiNewtonUpdater::DRS_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>DR * S (only for restoration phase) </p>

<p>Definition at line <a class="el" href="IpLimMemQuasiNewtonUpdater_8hpp_source.html#l00171">171</a> of file <a class="el" href="IpLimMemQuasiNewtonUpdater_8hpp_source.html">IpLimMemQuasiNewtonUpdater.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a05d855c245f0623a9aca28c3aa5ac14f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIpopt_1_1SmartPtr.html">SmartPtr</a>&lt;<a class="el" href="classIpopt_1_1DenseSymMatrix.html">DenseSymMatrix</a>&gt; Ipopt::LimMemQuasiNewtonUpdater::STDRS_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For efficient implementation, we store the S^T S DR * S. </p>
<p>Only for restoration phase. </p>

<p>Definition at line <a class="el" href="IpLimMemQuasiNewtonUpdater_8hpp_source.html#l00174">174</a> of file <a class="el" href="IpLimMemQuasiNewtonUpdater_8hpp_source.html">IpLimMemQuasiNewtonUpdater.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad6c924d457bfb616a2f11e6129dc25a1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIpopt_1_1SmartPtr.html">SmartPtr</a>&lt;const <a class="el" href="classIpopt_1_1Vector.html">Vector</a>&gt; Ipopt::LimMemQuasiNewtonUpdater::last_x_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Primal variables x from most recent update. </p>

<p>Definition at line <a class="el" href="IpLimMemQuasiNewtonUpdater_8hpp_source.html#l00176">176</a> of file <a class="el" href="IpLimMemQuasiNewtonUpdater_8hpp_source.html">IpLimMemQuasiNewtonUpdater.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8c01dfe9191fbd2bdae013541a07adf1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIpopt_1_1SmartPtr.html">SmartPtr</a>&lt;const <a class="el" href="classIpopt_1_1Vector.html">Vector</a>&gt; Ipopt::LimMemQuasiNewtonUpdater::last_grad_f_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gradient of objective function w.r.t. </p>
<p>x at x_last_ </p>

<p>Definition at line <a class="el" href="IpLimMemQuasiNewtonUpdater_8hpp_source.html#l00178">178</a> of file <a class="el" href="IpLimMemQuasiNewtonUpdater_8hpp_source.html">IpLimMemQuasiNewtonUpdater.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0b6ea6fbd20cbd6a907d2037727407d8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIpopt_1_1SmartPtr.html">SmartPtr</a>&lt;const <a class="el" href="classIpopt_1_1Matrix.html">Matrix</a>&gt; Ipopt::LimMemQuasiNewtonUpdater::last_jac_c_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Jacobian for equality constraints w.r.t x at x_last. </p>

<p>Definition at line <a class="el" href="IpLimMemQuasiNewtonUpdater_8hpp_source.html#l00180">180</a> of file <a class="el" href="IpLimMemQuasiNewtonUpdater_8hpp_source.html">IpLimMemQuasiNewtonUpdater.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a39cde08934dec5c9d07ee60bd9f894dc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIpopt_1_1SmartPtr.html">SmartPtr</a>&lt;const <a class="el" href="classIpopt_1_1Matrix.html">Matrix</a>&gt; Ipopt::LimMemQuasiNewtonUpdater::last_jac_d_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Jacobian for inequality constraints w.r.t x at x_last. </p>

<p>Definition at line <a class="el" href="IpLimMemQuasiNewtonUpdater_8hpp_source.html#l00182">182</a> of file <a class="el" href="IpLimMemQuasiNewtonUpdater_8hpp_source.html">IpLimMemQuasiNewtonUpdater.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af68441d4e1f531996c893ef537aefdd2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceIpopt.html#a8728e67558138991e8ee3fea451dca94">Index</a> Ipopt::LimMemQuasiNewtonUpdater::curr_lm_memory_old_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>current size of limited memory </p>

<p>Definition at line <a class="el" href="IpLimMemQuasiNewtonUpdater_8hpp_source.html#l00184">184</a> of file <a class="el" href="IpLimMemQuasiNewtonUpdater_8hpp_source.html">IpLimMemQuasiNewtonUpdater.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae39f3dcffe0149d85a578ecea3713ada"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIpopt_1_1SmartPtr.html">SmartPtr</a>&lt;<a class="el" href="classIpopt_1_1MultiVectorMatrix.html">MultiVectorMatrix</a>&gt; Ipopt::LimMemQuasiNewtonUpdater::S_old_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>s pairs for the recent iterations (backup) </p>

<p>Definition at line <a class="el" href="IpLimMemQuasiNewtonUpdater_8hpp_source.html#l00186">186</a> of file <a class="el" href="IpLimMemQuasiNewtonUpdater_8hpp_source.html">IpLimMemQuasiNewtonUpdater.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6b3a8ff337019f44b57d51ef4ab768a1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIpopt_1_1SmartPtr.html">SmartPtr</a>&lt;<a class="el" href="classIpopt_1_1MultiVectorMatrix.html">MultiVectorMatrix</a>&gt; Ipopt::LimMemQuasiNewtonUpdater::Y_old_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>y pairs for the recent iterations. </p>
<p>If update_for_resto is true, then this includes only the information for the constraints. (backup) </p>

<p>Definition at line <a class="el" href="IpLimMemQuasiNewtonUpdater_8hpp_source.html#l00190">190</a> of file <a class="el" href="IpLimMemQuasiNewtonUpdater_8hpp_source.html">IpLimMemQuasiNewtonUpdater.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1234b1ef46ef754744118ed65474489a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIpopt_1_1SmartPtr.html">SmartPtr</a>&lt;<a class="el" href="classIpopt_1_1MultiVectorMatrix.html">MultiVectorMatrix</a>&gt; Ipopt::LimMemQuasiNewtonUpdater::Ypart_old_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For restoration phase update: Y without the quadratic objective function part (backup) </p>

<p>Definition at line <a class="el" href="IpLimMemQuasiNewtonUpdater_8hpp_source.html#l00193">193</a> of file <a class="el" href="IpLimMemQuasiNewtonUpdater_8hpp_source.html">IpLimMemQuasiNewtonUpdater.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6b970b7904a109e21d61de28fd24f228"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIpopt_1_1SmartPtr.html">SmartPtr</a>&lt;<a class="el" href="classIpopt_1_1DenseVector.html">DenseVector</a>&gt; Ipopt::LimMemQuasiNewtonUpdater::D_old_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Diagonal elements D_k for compact formulation from last update (backup). </p>

<p>Definition at line <a class="el" href="IpLimMemQuasiNewtonUpdater_8hpp_source.html#l00196">196</a> of file <a class="el" href="IpLimMemQuasiNewtonUpdater_8hpp_source.html">IpLimMemQuasiNewtonUpdater.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab7bf7ad4de5fb03834605c0b30bcad00"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIpopt_1_1SmartPtr.html">SmartPtr</a>&lt;<a class="el" href="classIpopt_1_1DenseGenMatrix.html">DenseGenMatrix</a>&gt; Ipopt::LimMemQuasiNewtonUpdater::L_old_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classIpopt_1_1Matrix.html" title="Matrix Base Class. ">Matrix</a> L_k for compact formulation from last update (backup). </p>

<p>Definition at line <a class="el" href="IpLimMemQuasiNewtonUpdater_8hpp_source.html#l00198">198</a> of file <a class="el" href="IpLimMemQuasiNewtonUpdater_8hpp_source.html">IpLimMemQuasiNewtonUpdater.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7265d340c5f6d6e644d63377eec4b156"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIpopt_1_1SmartPtr.html">SmartPtr</a>&lt;<a class="el" href="classIpopt_1_1Vector.html">Vector</a>&gt; Ipopt::LimMemQuasiNewtonUpdater::B0_old_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>First term (starting matrix) for the approximation (backup). </p>

<p>Definition at line <a class="el" href="IpLimMemQuasiNewtonUpdater_8hpp_source.html#l00200">200</a> of file <a class="el" href="IpLimMemQuasiNewtonUpdater_8hpp_source.html">IpLimMemQuasiNewtonUpdater.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa17edd63f7905cec9abfa8d8d592009c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceIpopt.html#ad77ec4132352c5093febf9c488a72a4c">Number</a> Ipopt::LimMemQuasiNewtonUpdater::sigma_old_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>First term (starting matrix) for the approximation. </p>
<p>If that first terms is a multiple of the identy, sigma give that factor. Otherwise sigma = -1. (backup) </p>

<p>Definition at line <a class="el" href="IpLimMemQuasiNewtonUpdater_8hpp_source.html#l00204">204</a> of file <a class="el" href="IpLimMemQuasiNewtonUpdater_8hpp_source.html">IpLimMemQuasiNewtonUpdater.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="afc1b44ee463310533e3412c274d134ed"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIpopt_1_1SmartPtr.html">SmartPtr</a>&lt;<a class="el" href="classIpopt_1_1MultiVectorMatrix.html">MultiVectorMatrix</a>&gt; Ipopt::LimMemQuasiNewtonUpdater::V_old_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>V in LowRankUpdateMatrix from last update (backup) </p>

<p>Definition at line <a class="el" href="IpLimMemQuasiNewtonUpdater_8hpp_source.html#l00206">206</a> of file <a class="el" href="IpLimMemQuasiNewtonUpdater_8hpp_source.html">IpLimMemQuasiNewtonUpdater.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad98d84977d553282814871f362b61d52"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIpopt_1_1SmartPtr.html">SmartPtr</a>&lt;<a class="el" href="classIpopt_1_1MultiVectorMatrix.html">MultiVectorMatrix</a>&gt; Ipopt::LimMemQuasiNewtonUpdater::U_old_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>U in LowRankUpdateMatrix from last update (backup) </p>

<p>Definition at line <a class="el" href="IpLimMemQuasiNewtonUpdater_8hpp_source.html#l00208">208</a> of file <a class="el" href="IpLimMemQuasiNewtonUpdater_8hpp_source.html">IpLimMemQuasiNewtonUpdater.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0687e0f7dda8f9a396c81435d0572137"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIpopt_1_1SmartPtr.html">SmartPtr</a>&lt;<a class="el" href="classIpopt_1_1DenseSymMatrix.html">DenseSymMatrix</a>&gt; Ipopt::LimMemQuasiNewtonUpdater::SdotS_old_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For efficient implementation, we store the pairwise products for s's (backup). </p>

<p>Definition at line <a class="el" href="IpLimMemQuasiNewtonUpdater_8hpp_source.html#l00211">211</a> of file <a class="el" href="IpLimMemQuasiNewtonUpdater_8hpp_source.html">IpLimMemQuasiNewtonUpdater.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6d0dec49277cc4359cdd40a8c4923ec2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ipopt::LimMemQuasiNewtonUpdater::SdotS_uptodate_old_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Flag indicating whether SdotS_ is update to date from most recent update (backup). </p>

<p>Definition at line <a class="el" href="IpLimMemQuasiNewtonUpdater_8hpp_source.html#l00214">214</a> of file <a class="el" href="IpLimMemQuasiNewtonUpdater_8hpp_source.html">IpLimMemQuasiNewtonUpdater.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6a2281c42f2dec342bf32ada3454815f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIpopt_1_1SmartPtr.html">SmartPtr</a>&lt;<a class="el" href="classIpopt_1_1MultiVectorMatrix.html">MultiVectorMatrix</a>&gt; Ipopt::LimMemQuasiNewtonUpdater::DRS_old_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>DR * S (only for restoration phase) (backup) </p>

<p>Definition at line <a class="el" href="IpLimMemQuasiNewtonUpdater_8hpp_source.html#l00216">216</a> of file <a class="el" href="IpLimMemQuasiNewtonUpdater_8hpp_source.html">IpLimMemQuasiNewtonUpdater.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae13a4b50d8d9c7d22b115bc31e3c72c5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIpopt_1_1SmartPtr.html">SmartPtr</a>&lt;<a class="el" href="classIpopt_1_1DenseSymMatrix.html">DenseSymMatrix</a>&gt; Ipopt::LimMemQuasiNewtonUpdater::STDRS_old_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For efficient implementation, we store the S^T S DR * S. </p>
<p>Only for restoration phase. (backup) </p>

<p>Definition at line <a class="el" href="IpLimMemQuasiNewtonUpdater_8hpp_source.html#l00219">219</a> of file <a class="el" href="IpLimMemQuasiNewtonUpdater_8hpp_source.html">IpLimMemQuasiNewtonUpdater.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/Algorithm/<a class="el" href="IpLimMemQuasiNewtonUpdater_8hpp_source.html">IpLimMemQuasiNewtonUpdater.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Jun 13 2017 03:43:45 for Ipopt by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.5
</small></address>
</body>
</html>
