<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>Ipopt: Ipopt::SmartPtr&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Ipopt
   &#160;<span id="projectnumber">3.12.8</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceIpopt.html">Ipopt</a></li><li class="navelem"><a class="el" href="classIpopt_1_1SmartPtr.html">SmartPtr</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="classIpopt_1_1SmartPtr-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Ipopt::SmartPtr&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Template class for Smart Pointers.  
 <a href="classIpopt_1_1SmartPtr.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="IpSmartPtr_8hpp_source.html">IpSmartPtr.hpp</a>&gt;</code></p>

<p>Inherits <a class="el" href="classIpopt_1_1Referencer.html">Ipopt::Referencer</a>.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructors/Destructors</div></td></tr>
<tr class="memitem:a22ffa06afa6920141b3123cd520f8267"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIpopt_1_1SmartPtr.html#a22ffa06afa6920141b3123cd520f8267">SmartPtr</a> ()</td></tr>
<tr class="memdesc:a22ffa06afa6920141b3123cd520f8267"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor, initialized to NULL.  <a href="#a22ffa06afa6920141b3123cd520f8267">More...</a><br/></td></tr>
<tr class="separator:a22ffa06afa6920141b3123cd520f8267"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad76554afdafadf870e6e723a74585060"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIpopt_1_1SmartPtr.html#ad76554afdafadf870e6e723a74585060">SmartPtr</a> (const <a class="el" href="classIpopt_1_1SmartPtr.html">SmartPtr</a>&lt; T &gt; &amp;copy)</td></tr>
<tr class="memdesc:ad76554afdafadf870e6e723a74585060"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor, initialized from copy of type T.  <a href="#ad76554afdafadf870e6e723a74585060">More...</a><br/></td></tr>
<tr class="separator:ad76554afdafadf870e6e723a74585060"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24a8183411b35714f4eb319068198946"><td class="memTemplParams" colspan="2">template&lt;class U &gt; </td></tr>
<tr class="memitem:a24a8183411b35714f4eb319068198946"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classIpopt_1_1SmartPtr.html#a24a8183411b35714f4eb319068198946">SmartPtr</a> (const <a class="el" href="classIpopt_1_1SmartPtr.html">SmartPtr</a>&lt; U &gt; &amp;copy)</td></tr>
<tr class="memdesc:a24a8183411b35714f4eb319068198946"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor, initialized from copy of type U.  <a href="#a24a8183411b35714f4eb319068198946">More...</a><br/></td></tr>
<tr class="separator:a24a8183411b35714f4eb319068198946"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a803f6638971854c663155c072e074f7e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIpopt_1_1SmartPtr.html#a803f6638971854c663155c072e074f7e">SmartPtr</a> (T *ptr)</td></tr>
<tr class="memdesc:a803f6638971854c663155c072e074f7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor, initialized from T* ptr.  <a href="#a803f6638971854c663155c072e074f7e">More...</a><br/></td></tr>
<tr class="separator:a803f6638971854c663155c072e074f7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bc8430ef72a25d430ea0d9c738db035"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIpopt_1_1SmartPtr.html#a8bc8430ef72a25d430ea0d9c738db035">~SmartPtr</a> ()</td></tr>
<tr class="memdesc:a8bc8430ef72a25d430ea0d9c738db035"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor, automatically decrements the reference count, deletes the object if necessary.  <a href="#a8bc8430ef72a25d430ea0d9c738db035">More...</a><br/></td></tr>
<tr class="separator:a8bc8430ef72a25d430ea0d9c738db035"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">friend method declarations.</div></td></tr>
<tr class="memitem:a180b5cee7232bd9434217a44107e0861"><td class="memTemplParams" colspan="2">template&lt;class U &gt; </td></tr>
<tr class="memitem:a180b5cee7232bd9434217a44107e0861"><td class="memTemplItemLeft" align="right" valign="top">U *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classIpopt_1_1SmartPtr.html#a180b5cee7232bd9434217a44107e0861">GetRawPtr</a> (const <a class="el" href="classIpopt_1_1SmartPtr.html">SmartPtr</a>&lt; U &gt; &amp;smart_ptr)</td></tr>
<tr class="memdesc:a180b5cee7232bd9434217a44107e0861"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the raw pointer contained.  <a href="#a180b5cee7232bd9434217a44107e0861">More...</a><br/></td></tr>
<tr class="separator:a180b5cee7232bd9434217a44107e0861"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6d61ff0be07d9c05a67cadeb9a073f8"><td class="memTemplParams" colspan="2">template&lt;class U &gt; </td></tr>
<tr class="memitem:ac6d61ff0be07d9c05a67cadeb9a073f8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classIpopt_1_1SmartPtr.html">SmartPtr</a>&lt; const U &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classIpopt_1_1SmartPtr.html#ac6d61ff0be07d9c05a67cadeb9a073f8">ConstPtr</a> (const <a class="el" href="classIpopt_1_1SmartPtr.html">SmartPtr</a>&lt; U &gt; &amp;smart_ptr)</td></tr>
<tr class="memdesc:ac6d61ff0be07d9c05a67cadeb9a073f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const pointer.  <a href="#ac6d61ff0be07d9c05a67cadeb9a073f8">More...</a><br/></td></tr>
<tr class="separator:ac6d61ff0be07d9c05a67cadeb9a073f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac969d05f92a0038daf754ac1c5ab876"><td class="memTemplParams" colspan="2">template&lt;class U &gt; </td></tr>
<tr class="memitem:aac969d05f92a0038daf754ac1c5ab876"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classIpopt_1_1SmartPtr.html#aac969d05f92a0038daf754ac1c5ab876">IsValid</a> (const <a class="el" href="classIpopt_1_1SmartPtr.html">SmartPtr</a>&lt; U &gt; &amp;smart_ptr)</td></tr>
<tr class="memdesc:aac969d05f92a0038daf754ac1c5ab876"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the <a class="el" href="classIpopt_1_1SmartPtr.html" title="Template class for Smart Pointers. ">SmartPtr</a> is NOT NULL.  <a href="#aac969d05f92a0038daf754ac1c5ab876">More...</a><br/></td></tr>
<tr class="separator:aac969d05f92a0038daf754ac1c5ab876"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e3eb718ef30628e0c644bfdcdea989d"><td class="memTemplParams" colspan="2">template&lt;class U &gt; </td></tr>
<tr class="memitem:a4e3eb718ef30628e0c644bfdcdea989d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classIpopt_1_1SmartPtr.html#a4e3eb718ef30628e0c644bfdcdea989d">IsNull</a> (const <a class="el" href="classIpopt_1_1SmartPtr.html">SmartPtr</a>&lt; U &gt; &amp;smart_ptr)</td></tr>
<tr class="memdesc:a4e3eb718ef30628e0c644bfdcdea989d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the <a class="el" href="classIpopt_1_1SmartPtr.html" title="Template class for Smart Pointers. ">SmartPtr</a> is NULL.  <a href="#a4e3eb718ef30628e0c644bfdcdea989d">More...</a><br/></td></tr>
<tr class="separator:a4e3eb718ef30628e0c644bfdcdea989d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Overloaded operators.</h2></td></tr>
<tr class="memitem:a31700d4f21b89a5d0a1597e2a13f7f02"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIpopt_1_1SmartPtr.html#a31700d4f21b89a5d0a1597e2a13f7f02">operator-&gt;</a> () const </td></tr>
<tr class="memdesc:a31700d4f21b89a5d0a1597e2a13f7f02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloaded arrow operator, allows the user to call methods using the contained pointer.  <a href="#a31700d4f21b89a5d0a1597e2a13f7f02">More...</a><br/></td></tr>
<tr class="separator:a31700d4f21b89a5d0a1597e2a13f7f02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ed2447d238c617dab20a9a4011c270f"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIpopt_1_1SmartPtr.html#a7ed2447d238c617dab20a9a4011c270f">operator*</a> () const </td></tr>
<tr class="memdesc:a7ed2447d238c617dab20a9a4011c270f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloaded dereference operator, allows the user to dereference the contained pointer.  <a href="#a7ed2447d238c617dab20a9a4011c270f">More...</a><br/></td></tr>
<tr class="separator:a7ed2447d238c617dab20a9a4011c270f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa736cb13b486d7b56d46a7254a4e609"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIpopt_1_1SmartPtr.html">SmartPtr</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIpopt_1_1SmartPtr.html#aaa736cb13b486d7b56d46a7254a4e609">operator=</a> (T *rhs)</td></tr>
<tr class="memdesc:aaa736cb13b486d7b56d46a7254a4e609"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloaded equals operator, allows the user to set the value of the <a class="el" href="classIpopt_1_1SmartPtr.html" title="Template class for Smart Pointers. ">SmartPtr</a> from a raw pointer.  <a href="#aaa736cb13b486d7b56d46a7254a4e609">More...</a><br/></td></tr>
<tr class="separator:aaa736cb13b486d7b56d46a7254a4e609"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a887051c8109519c9cf9f346ce11a55b4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIpopt_1_1SmartPtr.html">SmartPtr</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIpopt_1_1SmartPtr.html#a887051c8109519c9cf9f346ce11a55b4">operator=</a> (const <a class="el" href="classIpopt_1_1SmartPtr.html">SmartPtr</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a887051c8109519c9cf9f346ce11a55b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloaded equals operator, allows the user to set the value of the <a class="el" href="classIpopt_1_1SmartPtr.html" title="Template class for Smart Pointers. ">SmartPtr</a> from another <a class="el" href="classIpopt_1_1SmartPtr.html" title="Template class for Smart Pointers. ">SmartPtr</a>.  <a href="#a887051c8109519c9cf9f346ce11a55b4">More...</a><br/></td></tr>
<tr class="separator:a887051c8109519c9cf9f346ce11a55b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad53603fb8cc95efe44758563f0c2bf16"><td class="memTemplParams" colspan="2">template&lt;class U &gt; </td></tr>
<tr class="memitem:ad53603fb8cc95efe44758563f0c2bf16"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classIpopt_1_1SmartPtr.html">SmartPtr</a>&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classIpopt_1_1SmartPtr.html#ad53603fb8cc95efe44758563f0c2bf16">operator=</a> (const <a class="el" href="classIpopt_1_1SmartPtr.html">SmartPtr</a>&lt; U &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ad53603fb8cc95efe44758563f0c2bf16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloaded equals operator, allows the user to set the value of the <a class="el" href="classIpopt_1_1SmartPtr.html" title="Template class for Smart Pointers. ">SmartPtr</a> from another <a class="el" href="classIpopt_1_1SmartPtr.html" title="Template class for Smart Pointers. ">SmartPtr</a> of a different type.  <a href="#ad53603fb8cc95efe44758563f0c2bf16">More...</a><br/></td></tr>
<tr class="separator:ad53603fb8cc95efe44758563f0c2bf16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c0a37eb0bcf3b054d0a32e1270bc705"><td class="memTemplParams" colspan="2">template&lt;class U1 , class U2 &gt; </td></tr>
<tr class="memitem:a5c0a37eb0bcf3b054d0a32e1270bc705"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classIpopt_1_1SmartPtr.html#a5c0a37eb0bcf3b054d0a32e1270bc705">operator==</a> (const <a class="el" href="classIpopt_1_1SmartPtr.html">SmartPtr</a>&lt; U1 &gt; &amp;lhs, const <a class="el" href="classIpopt_1_1SmartPtr.html">SmartPtr</a>&lt; U2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a5c0a37eb0bcf3b054d0a32e1270bc705"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloaded equality comparison operator, allows the user to compare the value of two SmartPtrs.  <a href="#a5c0a37eb0bcf3b054d0a32e1270bc705">More...</a><br/></td></tr>
<tr class="separator:a5c0a37eb0bcf3b054d0a32e1270bc705"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ae6c0fa7e1d082d4ac70eb13ef1a42d"><td class="memTemplParams" colspan="2">template&lt;class U1 , class U2 &gt; </td></tr>
<tr class="memitem:a6ae6c0fa7e1d082d4ac70eb13ef1a42d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classIpopt_1_1SmartPtr.html#a6ae6c0fa7e1d082d4ac70eb13ef1a42d">operator==</a> (const <a class="el" href="classIpopt_1_1SmartPtr.html">SmartPtr</a>&lt; U1 &gt; &amp;lhs, U2 *raw_rhs)</td></tr>
<tr class="memdesc:a6ae6c0fa7e1d082d4ac70eb13ef1a42d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloaded equality comparison operator, allows the user to compare the value of a <a class="el" href="classIpopt_1_1SmartPtr.html" title="Template class for Smart Pointers. ">SmartPtr</a> with a raw pointer.  <a href="#a6ae6c0fa7e1d082d4ac70eb13ef1a42d">More...</a><br/></td></tr>
<tr class="separator:a6ae6c0fa7e1d082d4ac70eb13ef1a42d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a606d88811c3808ee456098c476f9a351"><td class="memTemplParams" colspan="2">template&lt;class U1 , class U2 &gt; </td></tr>
<tr class="memitem:a606d88811c3808ee456098c476f9a351"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classIpopt_1_1SmartPtr.html#a606d88811c3808ee456098c476f9a351">operator==</a> (U1 *lhs, const <a class="el" href="classIpopt_1_1SmartPtr.html">SmartPtr</a>&lt; U2 &gt; &amp;raw_rhs)</td></tr>
<tr class="memdesc:a606d88811c3808ee456098c476f9a351"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloaded equality comparison operator, allows the user to compare the value of a raw pointer with a <a class="el" href="classIpopt_1_1SmartPtr.html" title="Template class for Smart Pointers. ">SmartPtr</a>.  <a href="#a606d88811c3808ee456098c476f9a351">More...</a><br/></td></tr>
<tr class="separator:a606d88811c3808ee456098c476f9a351"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5830da9a8edcea70c214a3cfd0d5be93"><td class="memTemplParams" colspan="2">template&lt;class U1 , class U2 &gt; </td></tr>
<tr class="memitem:a5830da9a8edcea70c214a3cfd0d5be93"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classIpopt_1_1SmartPtr.html#a5830da9a8edcea70c214a3cfd0d5be93">operator!=</a> (const <a class="el" href="classIpopt_1_1SmartPtr.html">SmartPtr</a>&lt; U1 &gt; &amp;lhs, const <a class="el" href="classIpopt_1_1SmartPtr.html">SmartPtr</a>&lt; U2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a5830da9a8edcea70c214a3cfd0d5be93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloaded in-equality comparison operator, allows the user to compare the value of two SmartPtrs.  <a href="#a5830da9a8edcea70c214a3cfd0d5be93">More...</a><br/></td></tr>
<tr class="separator:a5830da9a8edcea70c214a3cfd0d5be93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a184d462875e8cd414a1782b0b84189e3"><td class="memTemplParams" colspan="2">template&lt;class U1 , class U2 &gt; </td></tr>
<tr class="memitem:a184d462875e8cd414a1782b0b84189e3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classIpopt_1_1SmartPtr.html#a184d462875e8cd414a1782b0b84189e3">operator!=</a> (const <a class="el" href="classIpopt_1_1SmartPtr.html">SmartPtr</a>&lt; U1 &gt; &amp;lhs, U2 *raw_rhs)</td></tr>
<tr class="memdesc:a184d462875e8cd414a1782b0b84189e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloaded in-equality comparison operator, allows the user to compare the value of a <a class="el" href="classIpopt_1_1SmartPtr.html" title="Template class for Smart Pointers. ">SmartPtr</a> with a raw pointer.  <a href="#a184d462875e8cd414a1782b0b84189e3">More...</a><br/></td></tr>
<tr class="separator:a184d462875e8cd414a1782b0b84189e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30fa32ae58fc32b425fc1c107621f909"><td class="memTemplParams" colspan="2">template&lt;class U1 , class U2 &gt; </td></tr>
<tr class="memitem:a30fa32ae58fc32b425fc1c107621f909"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classIpopt_1_1SmartPtr.html#a30fa32ae58fc32b425fc1c107621f909">operator!=</a> (U1 *lhs, const <a class="el" href="classIpopt_1_1SmartPtr.html">SmartPtr</a>&lt; U2 &gt; &amp;raw_rhs)</td></tr>
<tr class="memdesc:a30fa32ae58fc32b425fc1c107621f909"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloaded in-equality comparison operator, allows the user to compare the value of a <a class="el" href="classIpopt_1_1SmartPtr.html" title="Template class for Smart Pointers. ">SmartPtr</a> with a raw pointer.  <a href="#a30fa32ae58fc32b425fc1c107621f909">More...</a><br/></td></tr>
<tr class="separator:a30fa32ae58fc32b425fc1c107621f909"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58c42d838a008fd27fb70dd34a4c613f"><td class="memTemplParams" colspan="2">template&lt;class U &gt; </td></tr>
<tr class="memitem:a58c42d838a008fd27fb70dd34a4c613f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classIpopt_1_1SmartPtr.html#a58c42d838a008fd27fb70dd34a4c613f">operator&lt;</a> (const <a class="el" href="classIpopt_1_1SmartPtr.html">SmartPtr</a>&lt; U &gt; &amp;lhs, const <a class="el" href="classIpopt_1_1SmartPtr.html">SmartPtr</a>&lt; U &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a58c42d838a008fd27fb70dd34a4c613f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloaded less-than comparison operator, allows the user to compare the value of two SmartPtrs.  <a href="#a58c42d838a008fd27fb70dd34a4c613f">More...</a><br/></td></tr>
<tr class="separator:a58c42d838a008fd27fb70dd34a4c613f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Private Data/Methods</h2></td></tr>
<tr class="memitem:ae00d70e645c2cd368cfca0f94208f482"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIpopt_1_1SmartPtr.html#ae00d70e645c2cd368cfca0f94208f482">ptr_</a></td></tr>
<tr class="memdesc:ae00d70e645c2cd368cfca0f94208f482"><td class="mdescLeft">&#160;</td><td class="mdescRight">Actual raw pointer to the object.  <a href="#ae00d70e645c2cd368cfca0f94208f482">More...</a><br/></td></tr>
<tr class="separator:ae00d70e645c2cd368cfca0f94208f482"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac30062cbfc36ce07136268d1b1c871b4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIpopt_1_1SmartPtr.html">SmartPtr</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIpopt_1_1SmartPtr.html#ac30062cbfc36ce07136268d1b1c871b4">SetFromRawPtr_</a> (T *rhs)</td></tr>
<tr class="memdesc:ac30062cbfc36ce07136268d1b1c871b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value of the internal raw pointer from another raw pointer, releasing the previously referenced object if necessary.  <a href="#ac30062cbfc36ce07136268d1b1c871b4">More...</a><br/></td></tr>
<tr class="separator:ac30062cbfc36ce07136268d1b1c871b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20af4eff33e6b2bd0ca4e5891c484944"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIpopt_1_1SmartPtr.html">SmartPtr</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIpopt_1_1SmartPtr.html#a20af4eff33e6b2bd0ca4e5891c484944">SetFromSmartPtr_</a> (const <a class="el" href="classIpopt_1_1SmartPtr.html">SmartPtr</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a20af4eff33e6b2bd0ca4e5891c484944"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value of the internal raw pointer from a <a class="el" href="classIpopt_1_1SmartPtr.html" title="Template class for Smart Pointers. ">SmartPtr</a>, releasing the previously referenced object if necessary.  <a href="#a20af4eff33e6b2bd0ca4e5891c484944">More...</a><br/></td></tr>
<tr class="separator:a20af4eff33e6b2bd0ca4e5891c484944"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab74ca6e796ac58fa4ad335d8112ffae2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIpopt_1_1SmartPtr.html#ab74ca6e796ac58fa4ad335d8112ffae2">ReleasePointer_</a> ()</td></tr>
<tr class="memdesc:ab74ca6e796ac58fa4ad335d8112ffae2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release the currently referenced object.  <a href="#ab74ca6e796ac58fa4ad335d8112ffae2">More...</a><br/></td></tr>
<tr class="separator:ab74ca6e796ac58fa4ad335d8112ffae2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class T&gt;<br/>
class Ipopt::SmartPtr&lt; T &gt;</h3>

<p>Template class for Smart Pointers. </p>
<p>A <a class="el" href="classIpopt_1_1SmartPtr.html" title="Template class for Smart Pointers. ">SmartPtr</a> behaves much like a raw pointer, but manages the lifetime of an object, deleting the object automatically. This class implements a reference-counting, intrusive smart pointer design, where all objects pointed to must inherit off of <a class="el" href="classIpopt_1_1ReferencedObject.html" title="ReferencedObject class. ">ReferencedObject</a>, which stores the reference count. Although this is intrusive (native types and externally authored classes require wrappers to be referenced by smart pointers), it is a safer design. A more detailed discussion of these issues follows after the usage information.</p>
<p>Usage Example: Note: to use the <a class="el" href="classIpopt_1_1SmartPtr.html" title="Template class for Smart Pointers. ">SmartPtr</a>, all objects to which you point MUST inherit off of <a class="el" href="classIpopt_1_1ReferencedObject.html" title="ReferencedObject class. ">ReferencedObject</a>.</p>
<pre class="fragment">* 
* In MyClass.hpp...
* 
* #include "IpReferenced.hpp"

* namespace Ipopt {
* 
*  class MyClass : public ReferencedObject // must derive from ReferencedObject
*    {
*      ...
*    }
* } // namespace Ipopt
* 
* 
* In my_usage.cpp...
* 
* #include "IpSmartPtr.hpp"
* #include "MyClass.hpp"
* 
* void func(AnyObject&amp; obj)
*  {
*    SmartPtr&lt;MyClass&gt; ptr_to_myclass = new MyClass(...);
*    // ptr_to_myclass now points to a new MyClass,
*    // and the reference count is 1
*  
*    ...
* 
*    obj.SetMyClass(ptr_to_myclass);
*    // Here, let's assume that AnyObject uses a
*    // SmartPtr&lt;MyClass&gt; internally here.
*    // Now, both ptr_to_myclass and the internal
*    // SmartPtr in obj point to the same MyClass object
*    // and its reference count is 2.
* 
*    ...
* 
*    // No need to delete ptr_to_myclass, this
*    // will be done automatically when the
*    // reference count drops to zero.
* 
*  }  
*  
* </pre><p>It is not necessary to use <a class="el" href="classIpopt_1_1SmartPtr.html" title="Template class for Smart Pointers. ">SmartPtr</a>'s in all cases where an object is used that has been allocated "into" a <a class="el" href="classIpopt_1_1SmartPtr.html" title="Template class for Smart Pointers. ">SmartPtr</a>. It is possible to just pass objects by reference or regular pointers, even if lower down in the stack a <a class="el" href="classIpopt_1_1SmartPtr.html" title="Template class for Smart Pointers. ">SmartPtr</a> is to be held on to. Everything should work fine as long as a pointer created by "new" is immediately passed into a <a class="el" href="classIpopt_1_1SmartPtr.html" title="Template class for Smart Pointers. ">SmartPtr</a>, and if <a class="el" href="classIpopt_1_1SmartPtr.html" title="Template class for Smart Pointers. ">SmartPtr</a>'s are used to hold on to objects.</p>
<p>Other Notes: The <a class="el" href="classIpopt_1_1SmartPtr.html" title="Template class for Smart Pointers. ">SmartPtr</a> implements both dereference operators -&gt; &amp; *. The <a class="el" href="classIpopt_1_1SmartPtr.html" title="Template class for Smart Pointers. ">SmartPtr</a> does NOT implement a conversion operator to the raw pointer. Use the <a class="el" href="classIpopt_1_1SmartPtr.html#a180b5cee7232bd9434217a44107e0861" title="Returns the raw pointer contained. ">GetRawPtr()</a> method when this is necessary. Make sure that the raw pointer is NOT deleted. The <a class="el" href="classIpopt_1_1SmartPtr.html" title="Template class for Smart Pointers. ">SmartPtr</a> implements the comparison operators == &amp; != for a variety of types. Use these instead of </p>
<pre class="fragment">*    if (GetRawPtr(smrt_ptr) == ptr) // Don't use this
*    </pre><p> <a class="el" href="classIpopt_1_1SmartPtr.html" title="Template class for Smart Pointers. ">SmartPtr</a>'s, as currently implemented, do NOT handle circular references. For example: consider a higher level object using SmartPtrs to point to A and B, but A and B also point to each other (i.e. A has a <a class="el" href="classIpopt_1_1SmartPtr.html" title="Template class for Smart Pointers. ">SmartPtr</a> to B and B has a <a class="el" href="classIpopt_1_1SmartPtr.html" title="Template class for Smart Pointers. ">SmartPtr</a> to A). In this scenario, when the higher level object is finished with A and B, their reference counts will never drop to zero (since they reference each other) and they will not be deleted. This can be detected by memory leak tools like valgrind. If the circular reference is necessary, the problem can be overcome by a number of techniques:</p>
<p>1) A and B can have a method that "releases" each other, that is they set their internal SmartPtrs to NULL. </p>
<pre class="fragment">*        void AClass::ReleaseCircularReferences()
*          {
*          smart_ptr_to_B = NULL;
*          }
*        </pre><p> Then, the higher level class can call these methods before it is done using A &amp; B.</p>
<p>2) Raw pointers can be used in A and B to reference each other. Here, an implicit assumption is made that the lifetime is controlled by the higher level object and that A and B will both exist in a controlled manner. Although this seems dangerous, in many situations, this type of referencing is very controlled and this is reasonably safe.</p>
<p>3) This <a class="el" href="classIpopt_1_1SmartPtr.html" title="Template class for Smart Pointers. ">SmartPtr</a> class could be redesigned with the Weak/Strong design concept. Here, the <a class="el" href="classIpopt_1_1SmartPtr.html" title="Template class for Smart Pointers. ">SmartPtr</a> is identified as being Strong (controls lifetime of the object) or Weak (merely referencing the object). The Strong <a class="el" href="classIpopt_1_1SmartPtr.html" title="Template class for Smart Pointers. ">SmartPtr</a> increments (and decrements) the reference count in <a class="el" href="classIpopt_1_1ReferencedObject.html" title="ReferencedObject class. ">ReferencedObject</a> but the Weak <a class="el" href="classIpopt_1_1SmartPtr.html" title="Template class for Smart Pointers. ">SmartPtr</a> does not. In the example above, the higher level object would have Strong SmartPtrs to A and B, but A and B would have Weak SmartPtrs to each other. Then, when the higher level object was done with A and B, they would be deleted. The Weak SmartPtrs in A and B would not decrement the reference count and would, of course, not delete the object. This idea is very similar to item (2), where it is implied that the sequence of events is controlled such that A and B will not call anything using their pointers following the higher level delete (i.e. in their destructors!). This is somehow safer, however, because code can be written (however expensive) to perform run-time detection of this situation. For example, the <a class="el" href="classIpopt_1_1ReferencedObject.html" title="ReferencedObject class. ">ReferencedObject</a> could store pointers to all Weak SmartPtrs that are referencing it and, in its destructor, tell these pointers that it is dying. They could then set themselves to NULL, or set an internal flag to detect usage past this point.</p>
<p>Comments on Non-Intrusive Design: In a non-intrusive design, the reference count is stored somewhere other than the object being referenced. This means, unless the reference counting pointer is the first referencer, it must get a pointer to the referenced object from another smart pointer (so it has access to the reference count location). In this non-intrusive design, if we are pointing to an object with a smart pointer (or a number of smart pointers), and we then give another smart pointer the address through a RAW pointer, we will have two independent, AND INCORRECT, reference counts. To avoid this pitfall, we use an intrusive reference counting technique where the reference count is stored in the object being referenced. </p>

<p>Definition at line <a class="el" href="IpSmartPtr_8hpp_source.html#l00172">172</a> of file <a class="el" href="IpSmartPtr_8hpp_source.html">IpSmartPtr.hpp</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a22ffa06afa6920141b3123cd520f8267"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIpopt_1_1SmartPtr.html">Ipopt::SmartPtr</a>&lt; T &gt;::<a class="el" href="classIpopt_1_1SmartPtr.html">SmartPtr</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default constructor, initialized to NULL. </p>

<p>Definition at line <a class="el" href="IpSmartPtr_8hpp_source.html#l00361">361</a> of file <a class="el" href="IpSmartPtr_8hpp_source.html">IpSmartPtr.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad76554afdafadf870e6e723a74585060"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIpopt_1_1SmartPtr.html">Ipopt::SmartPtr</a>&lt; T &gt;::<a class="el" href="classIpopt_1_1SmartPtr.html">SmartPtr</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIpopt_1_1SmartPtr.html">SmartPtr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>copy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy constructor, initialized from copy of type T. </p>

<p>Definition at line <a class="el" href="IpSmartPtr_8hpp_source.html#l00377">377</a> of file <a class="el" href="IpSmartPtr_8hpp_source.html">IpSmartPtr.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a24a8183411b35714f4eb319068198946"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<div class="memtemplate">
template&lt;class U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIpopt_1_1SmartPtr.html">Ipopt::SmartPtr</a>&lt; T &gt;::<a class="el" href="classIpopt_1_1SmartPtr.html">SmartPtr</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIpopt_1_1SmartPtr.html">SmartPtr</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>copy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy constructor, initialized from copy of type U. </p>

<p>Definition at line <a class="el" href="IpSmartPtr_8hpp_source.html#l00395">395</a> of file <a class="el" href="IpSmartPtr_8hpp_source.html">IpSmartPtr.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a803f6638971854c663155c072e074f7e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIpopt_1_1SmartPtr.html">Ipopt::SmartPtr</a>&lt; T &gt;::<a class="el" href="classIpopt_1_1SmartPtr.html">SmartPtr</a> </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor, initialized from T* ptr. </p>

<p>Definition at line <a class="el" href="IpSmartPtr_8hpp_source.html#l00412">412</a> of file <a class="el" href="IpSmartPtr_8hpp_source.html">IpSmartPtr.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8bc8430ef72a25d430ea0d9c738db035"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIpopt_1_1SmartPtr.html">Ipopt::SmartPtr</a>&lt; T &gt;::~<a class="el" href="classIpopt_1_1SmartPtr.html">SmartPtr</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destructor, automatically decrements the reference count, deletes the object if necessary. </p>

<p>Definition at line <a class="el" href="IpSmartPtr_8hpp_source.html#l00428">428</a> of file <a class="el" href="IpSmartPtr_8hpp_source.html">IpSmartPtr.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a31700d4f21b89a5d0a1597e2a13f7f02"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T * <a class="el" href="classIpopt_1_1SmartPtr.html">Ipopt::SmartPtr</a>&lt; T &gt;::operator-&gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overloaded arrow operator, allows the user to call methods using the contained pointer. </p>

<p>Definition at line <a class="el" href="IpSmartPtr_8hpp_source.html#l00439">439</a> of file <a class="el" href="IpSmartPtr_8hpp_source.html">IpSmartPtr.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7ed2447d238c617dab20a9a4011c270f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T &amp; <a class="el" href="classIpopt_1_1SmartPtr.html">Ipopt::SmartPtr</a>&lt; T &gt;::operator* </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overloaded dereference operator, allows the user to dereference the contained pointer. </p>

<p>Definition at line <a class="el" href="IpSmartPtr_8hpp_source.html#l00455">455</a> of file <a class="el" href="IpSmartPtr_8hpp_source.html">IpSmartPtr.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aaa736cb13b486d7b56d46a7254a4e609"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIpopt_1_1SmartPtr.html">SmartPtr</a>&lt; T &gt; &amp; <a class="el" href="classIpopt_1_1SmartPtr.html">Ipopt::SmartPtr</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overloaded equals operator, allows the user to set the value of the <a class="el" href="classIpopt_1_1SmartPtr.html" title="Template class for Smart Pointers. ">SmartPtr</a> from a raw pointer. </p>

<p>Definition at line <a class="el" href="IpSmartPtr_8hpp_source.html#l00471">471</a> of file <a class="el" href="IpSmartPtr_8hpp_source.html">IpSmartPtr.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a887051c8109519c9cf9f346ce11a55b4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIpopt_1_1SmartPtr.html">SmartPtr</a>&lt; T &gt; &amp; <a class="el" href="classIpopt_1_1SmartPtr.html">Ipopt::SmartPtr</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIpopt_1_1SmartPtr.html">SmartPtr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overloaded equals operator, allows the user to set the value of the <a class="el" href="classIpopt_1_1SmartPtr.html" title="Template class for Smart Pointers. ">SmartPtr</a> from another <a class="el" href="classIpopt_1_1SmartPtr.html" title="Template class for Smart Pointers. ">SmartPtr</a>. </p>

<p>Definition at line <a class="el" href="IpSmartPtr_8hpp_source.html#l00482">482</a> of file <a class="el" href="IpSmartPtr_8hpp_source.html">IpSmartPtr.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad53603fb8cc95efe44758563f0c2bf16"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<div class="memtemplate">
template&lt;class U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIpopt_1_1SmartPtr.html">SmartPtr</a>&lt; T &gt; &amp; <a class="el" href="classIpopt_1_1SmartPtr.html">Ipopt::SmartPtr</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIpopt_1_1SmartPtr.html">SmartPtr</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overloaded equals operator, allows the user to set the value of the <a class="el" href="classIpopt_1_1SmartPtr.html" title="Template class for Smart Pointers. ">SmartPtr</a> from another <a class="el" href="classIpopt_1_1SmartPtr.html" title="Template class for Smart Pointers. ">SmartPtr</a> of a different type. </p>

<p>Definition at line <a class="el" href="IpSmartPtr_8hpp_source.html#l00496">496</a> of file <a class="el" href="IpSmartPtr_8hpp_source.html">IpSmartPtr.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac30062cbfc36ce07136268d1b1c871b4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIpopt_1_1SmartPtr.html">SmartPtr</a>&lt; T &gt; &amp; <a class="el" href="classIpopt_1_1SmartPtr.html">Ipopt::SmartPtr</a>&lt; T &gt;::SetFromRawPtr_ </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the value of the internal raw pointer from another raw pointer, releasing the previously referenced object if necessary. </p>

<p>Definition at line <a class="el" href="IpSmartPtr_8hpp_source.html#l00509">509</a> of file <a class="el" href="IpSmartPtr_8hpp_source.html">IpSmartPtr.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a20af4eff33e6b2bd0ca4e5891c484944"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIpopt_1_1SmartPtr.html">SmartPtr</a>&lt; T &gt; &amp; <a class="el" href="classIpopt_1_1SmartPtr.html">Ipopt::SmartPtr</a>&lt; T &gt;::SetFromSmartPtr_ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIpopt_1_1SmartPtr.html">SmartPtr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the value of the internal raw pointer from a <a class="el" href="classIpopt_1_1SmartPtr.html" title="Template class for Smart Pointers. ">SmartPtr</a>, releasing the previously referenced object if necessary. </p>

<p>Definition at line <a class="el" href="IpSmartPtr_8hpp_source.html#l00528">528</a> of file <a class="el" href="IpSmartPtr_8hpp_source.html">IpSmartPtr.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab74ca6e796ac58fa4ad335d8112ffae2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classIpopt_1_1SmartPtr.html">Ipopt::SmartPtr</a>&lt; T &gt;::ReleasePointer_ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Release the currently referenced object. </p>

<p>Definition at line <a class="el" href="IpSmartPtr_8hpp_source.html#l00543">543</a> of file <a class="el" href="IpSmartPtr_8hpp_source.html">IpSmartPtr.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a class="anchor" id="a5c0a37eb0bcf3b054d0a32e1270bc705"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;class U1 , class U2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIpopt_1_1SmartPtr.html">SmartPtr</a>&lt; U1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIpopt_1_1SmartPtr.html">SmartPtr</a>&lt; U2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overloaded equality comparison operator, allows the user to compare the value of two SmartPtrs. </p>

</div>
</div>
<a class="anchor" id="a6ae6c0fa7e1d082d4ac70eb13ef1a42d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;class U1 , class U2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIpopt_1_1SmartPtr.html">SmartPtr</a>&lt; U1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U2 *&#160;</td>
          <td class="paramname"><em>raw_rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overloaded equality comparison operator, allows the user to compare the value of a <a class="el" href="classIpopt_1_1SmartPtr.html" title="Template class for Smart Pointers. ">SmartPtr</a> with a raw pointer. </p>

</div>
</div>
<a class="anchor" id="a606d88811c3808ee456098c476f9a351"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;class U1 , class U2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">U1 *&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIpopt_1_1SmartPtr.html">SmartPtr</a>&lt; U2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>raw_rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overloaded equality comparison operator, allows the user to compare the value of a raw pointer with a <a class="el" href="classIpopt_1_1SmartPtr.html" title="Template class for Smart Pointers. ">SmartPtr</a>. </p>

</div>
</div>
<a class="anchor" id="a5830da9a8edcea70c214a3cfd0d5be93"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;class U1 , class U2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIpopt_1_1SmartPtr.html">SmartPtr</a>&lt; U1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIpopt_1_1SmartPtr.html">SmartPtr</a>&lt; U2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overloaded in-equality comparison operator, allows the user to compare the value of two SmartPtrs. </p>

</div>
</div>
<a class="anchor" id="a184d462875e8cd414a1782b0b84189e3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;class U1 , class U2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIpopt_1_1SmartPtr.html">SmartPtr</a>&lt; U1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U2 *&#160;</td>
          <td class="paramname"><em>raw_rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overloaded in-equality comparison operator, allows the user to compare the value of a <a class="el" href="classIpopt_1_1SmartPtr.html" title="Template class for Smart Pointers. ">SmartPtr</a> with a raw pointer. </p>

</div>
</div>
<a class="anchor" id="a30fa32ae58fc32b425fc1c107621f909"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;class U1 , class U2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">U1 *&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIpopt_1_1SmartPtr.html">SmartPtr</a>&lt; U2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>raw_rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overloaded in-equality comparison operator, allows the user to compare the value of a <a class="el" href="classIpopt_1_1SmartPtr.html" title="Template class for Smart Pointers. ">SmartPtr</a> with a raw pointer. </p>

</div>
</div>
<a class="anchor" id="a58c42d838a008fd27fb70dd34a4c613f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIpopt_1_1SmartPtr.html">SmartPtr</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIpopt_1_1SmartPtr.html">SmartPtr</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overloaded less-than comparison operator, allows the user to compare the value of two SmartPtrs. </p>

</div>
</div>
<a class="anchor" id="a180b5cee7232bd9434217a44107e0861"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">U* GetRawPtr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIpopt_1_1SmartPtr.html">SmartPtr</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>smart_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the raw pointer contained. </p>
<p>Use to get the value of the raw ptr (i.e. to pass to other methods/functions, etc.) Note: This method does NOT copy, therefore, modifications using this value modify the underlying object contained by the <a class="el" href="classIpopt_1_1SmartPtr.html" title="Template class for Smart Pointers. ">SmartPtr</a>, NEVER delete this returned value. </p>

</div>
</div>
<a class="anchor" id="ac6d61ff0be07d9c05a67cadeb9a073f8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIpopt_1_1SmartPtr.html">SmartPtr</a>&lt;const U&gt; ConstPtr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIpopt_1_1SmartPtr.html">SmartPtr</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>smart_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const pointer. </p>

</div>
</div>
<a class="anchor" id="aac969d05f92a0038daf754ac1c5ab876"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool IsValid </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIpopt_1_1SmartPtr.html">SmartPtr</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>smart_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the <a class="el" href="classIpopt_1_1SmartPtr.html" title="Template class for Smart Pointers. ">SmartPtr</a> is NOT NULL. </p>
<p>Use this to check if the <a class="el" href="classIpopt_1_1SmartPtr.html" title="Template class for Smart Pointers. ">SmartPtr</a> is not null This is preferred to if(GetRawPtr(sp) != NULL) </p>

</div>
</div>
<a class="anchor" id="a4e3eb718ef30628e0c644bfdcdea989d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool IsNull </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIpopt_1_1SmartPtr.html">SmartPtr</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>smart_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the <a class="el" href="classIpopt_1_1SmartPtr.html" title="Template class for Smart Pointers. ">SmartPtr</a> is NULL. </p>
<p>Use this to check if the <a class="el" href="classIpopt_1_1SmartPtr.html" title="Template class for Smart Pointers. ">SmartPtr</a> IsNull. This is preferred to if(GetRawPtr(sp) == NULL) </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="ae00d70e645c2cd368cfca0f94208f482"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="classIpopt_1_1SmartPtr.html">Ipopt::SmartPtr</a>&lt; T &gt;::ptr_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Actual raw pointer to the object. </p>

<p>Definition at line <a class="el" href="IpSmartPtr_8hpp_source.html#l00308">308</a> of file <a class="el" href="IpSmartPtr_8hpp_source.html">IpSmartPtr.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/Common/<a class="el" href="IpSmartPtr_8hpp_source.html">IpSmartPtr.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Jun 13 2017 03:43:46 for Ipopt by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.5
</small></address>
</body>
</html>
